<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Class read_write_mutex</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.68.1">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../thread/reference.html#header.boost.thread.read_write_mutex.hpp" title="Header &lt;boost/thread/read_write_mutex.hpp&gt;">
<link rel="prev" href="read_write_scheduling_policy/read_write_scheduling_policy.html" title="Type read_write_scheduling_policy">
<link rel="next" href="try_read_write_mutex.html" title="Class try_read_write_mutex">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%">
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.htm">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="../../../people/people.htm">People</a></td>
<td align="center"><a href="../../../more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="read_write_scheduling_policy/read_write_scheduling_policy.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../thread/reference.html#header.boost.thread.read_write_mutex.hpp"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="try_read_write_mutex.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.read_write_mutex"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class read_write_mutex</span></h2>
<p>boost::read_write_mutex &#8212; <p>The <a href="read_write_mutex.html" title="Class read_write_mutex">read_write_mutex</a> class is a model of the 
			<a href="../thread/concepts.html#thread.concepts.ReadWriteMutex" title="ReadWriteMutex Concept">ReadWriteMutex</a> concept.</p><div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"> Unfortunately it turned out that the current implementation of Read/Write Mutex has     
            some serious problems. So it was decided not to put this implementation into
            release grade code. Also discussions on the mailing list led to the
            conclusion that the current concepts need to be rethought. In particular
            the schedulings <a href="../thread/concepts.html#thread.concepts.read-write-scheduling-policies.inter-class" title="Inter-Class Scheduling Policies">
                Inter-Class Scheduling Policies</a> are deemed unnecessary.
            There seems to be common belief that a fair scheme suffices.
            The following documentation has been retained however, to give
            readers of this document the opportunity to study the original design.
    </td></tr>
</table></div></p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis">
<span class="bold"><strong>class</strong></span> read_write_mutex : <span class="bold"><strong>private</strong></span> boost::noncopyable,  <span class="emphasis"><em>// Exposition only</em></span>
                         <span class="bold"><strong>private</strong></span> boost::noncopyable   <span class="emphasis"><em>// Exposition only</em></span>
{
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// types</em></span>
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> scoped_read_write_lock;
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> scoped_read_lock;      
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>implementation-defined</em></span> scoped_write_lock;     

  <span class="emphasis"><em>// <a href="read_write_mutex.html#boost.read_write_mutexconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a href="read_write_mutex.html#id1275854-bb">read_write_mutex</a>(boost::read_write_scheduling_policy);
  <a href="read_write_mutex.html#id1289193-bb">~read_write_mutex</a>();
};</pre></div>
<div class="refsect1" lang="en">
<a name="id1741938"></a><h2>Description</h2>
<p>The <a href="read_write_mutex.html" title="Class read_write_mutex">read_write_mutex</a> class is a model of the 
			<a href="../thread/concepts.html#thread.concepts.ReadWriteMutex" title="ReadWriteMutex Concept">ReadWriteMutex</a> concept. 
			It should be used to synchronize access to shared resources using
			<a href="../thread/concepts.html#thread.concepts.read-write-locking-strategies.unspecified" title="Unspecified Locking Strategy">Unspecified</a>
			locking mechanics.</p>
<p>For classes that model related mutex concepts, see 
			<a href="try_read_write_mutex.html" title="Class try_read_write_mutex">try_read_write_mutex</a> and <a href="timed_read_write_mutex.html" title="Class timed_read_write_mutex">timed_read_write_mutex</a>.</p>
<p>The <a href="read_write_mutex.html" title="Class read_write_mutex">read_write_mutex</a> class supplies the following typedefs,
			which <a href="../thread/concepts.html#thread.concepts.read-write-lock-models" title="Lock Models">model</a>
			the specified locking strategies:

			</p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th align="left">Lock Name</th>
<th align="left">Lock Concept</th>
</tr></thead>
<tbody>
<tr>
<td align="left">scoped_read_write_lock</td>
<td align="left"><a href="../thread/concepts.html#thread.concepts.ScopedReadWriteLock" title="ScopedReadWriteLock Concept">ScopedReadWriteLock</a></td>
</tr>
<tr>
<td align="left">scoped_read_lock</td>
<td align="left"><a href="../thread/concepts.html#thread.concepts.ScopedLock" title="ScopedLock Concept">ScopedLock</a></td>
</tr>
<tr>
<td align="left">scoped_write_lock</td>
<td align="left"><a href="../thread/concepts.html#thread.concepts.ScopedLock" title="ScopedLock Concept">ScopedLock</a></td>
</tr>
</tbody>
</table></div>
<p>			
			</p>
<p>The <a href="read_write_mutex.html" title="Class read_write_mutex">read_write_mutex</a> class uses an 
			<a href="../thread/concepts.html#thread.concepts.read-write-locking-strategies.unspecified" title="Unspecified Locking Strategy">Unspecified</a>
			locking strategy, so attempts to recursively lock a <a href="read_write_mutex.html" title="Class read_write_mutex">read_write_mutex</a>
			object or attempts to unlock one by threads that don't own a lock on it result in
			<span class="bold"><strong>undefined behavior</strong></span>.
			This strategy allows implementations to be as efficient as possible
			on any given platform. It is, however, recommended that
			implementations include debugging support to detect misuse when
			<code class="computeroutput">NDEBUG</code> is not defined.</p>
<p>Like all
			<a href="../thread/concepts.html#thread.concepts.read-write-mutex-models" title="Mutex Models">read/write mutex models</a>
			in <span class="bold"><strong>Boost.Thread</strong></span>, <a href="read_write_mutex.html" title="Class read_write_mutex">read_write_mutex</a> has two types of
			<a href="../thread/concepts.html#thread.concepts.read-write-scheduling-policies" title="Scheduling Policies">scheduling policies</a>, an 
			<a href="../thread/concepts.html#thread.concepts.read-write-scheduling-policies.inter-class" title="Inter-Class Scheduling Policies">inter-class sheduling policy</a>
			between threads trying to obtain different types of locks and an
			<a href="../thread/concepts.html#thread.concepts.read-write-scheduling-policies.intra-class" title="Intra-Class Scheduling Policies">intra-class sheduling policy</a>
			between threads trying to obtain the same type of lock.
			The <a href="read_write_mutex.html" title="Class read_write_mutex">read_write_mutex</a> class allows the
			programmer to choose what
			<a href="../thread/concepts.html#thread.concepts.read-write-scheduling-policies.inter-class" title="Inter-Class Scheduling Policies">inter-class sheduling policy</a>
			will be used; however, like all read/write mutex models, 
			<a href="read_write_mutex.html" title="Class read_write_mutex">read_write_mutex</a> leaves the 
			<a href="../thread/concepts.html#thread.concepts.read-write-scheduling-policies.intra-class" title="Intra-Class Scheduling Policies">intra-class sheduling policy</a> as 
			<a href="../thread/concepts.html#thread.concepts.read-write-locking-strategies.unspecified" title="Unspecified Locking Strategy">Unspecified</a>.			
			</p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">Self-deadlock is virtually guaranteed if a thread tries to
			lock the same <a href="read_write_mutex.html" title="Class read_write_mutex">read_write_mutex</a> multiple times
			unless all locks are read-locks (but see below)</td></tr>
</table></div>
<div class="refsect2" lang="en">
<a name="id1742245"></a><h3>
<a name="boost.read_write_mutexconstruct-copy-destruct"></a><code class="computeroutput">read_write_mutex</code> construct/copy/destruct</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id1275854-bb"></a>read_write_mutex(boost::read_write_scheduling_policy count);</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td>
<span class="term">Effects:</span></td>
<td>Constructs a <a href="read_write_mutex.html" title="Class read_write_mutex">read_write_mutex</a> object.
			</td>
</tr>
<tr>
<td>
<span class="term">Postconditions:</span></td>
<td>
<code class="computeroutput">*this</code> is in an unlocked state.
			</td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id1289193-bb"></a>~read_write_mutex();</pre>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td>
<span class="term">Effects:</span></td>
<td>Destroys a <a href="read_write_mutex.html" title="Class read_write_mutex">read_write_mutex</a> object.</td>
</tr>
<tr>
<td>
<span class="term">Requires:</span></td>
<td>
<code class="computeroutput">*this</code> is in an unlocked state.</td>
</tr>
<tr>
<td>
<span class="term">Notes:</span></td>
<td>
<span class="bold"><strong>Danger:</strong></span> Destruction of a
			locked mutex is a serious programming error resulting in undefined
			behavior such as a program crash.</td>
</tr>
</tbody>
</table></div>
</li>
</ol></div>
</div>
</div>
</div>
<table width="100%"><tr>
<td align="left"></td>
<td align="right"><small>Copyright © 2001-2003 William E. Kempf</small></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="read_write_scheduling_policy/read_write_scheduling_policy.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../thread/reference.html#header.boost.thread.read_write_mutex.hpp"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="try_read_write_mutex.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
