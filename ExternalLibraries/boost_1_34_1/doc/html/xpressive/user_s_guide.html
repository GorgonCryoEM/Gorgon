<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>User's Guide</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.68.1">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../xpressive.html" title="Chapter 21. Boost.Xpressive">
<link rel="prev" href="../xpressive.html" title="Chapter 21. Boost.Xpressive">
<link rel="next" href="reference.html" title="Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%">
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.htm">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="../../../people/people.htm">People</a></td>
<td align="center"><a href="../../../more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../xpressive.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../xpressive.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="reference.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="xpressive.user_s_guide"></a>User's Guide</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.introduction">Introduction</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.installing_xpressive">Installing xpressive</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.quick_start">Quick Start</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#xpressive.user_s_guide.creating_a_regex_object">Creating a Regex Object</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.matching_and_searching">Matching and Searching</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.accessing_results">Accessing Results</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.string_substitutions">String Substitutions</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.string_splitting_and_tokenization">String Splitting and Tokenization</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches">Grammars and Nested Matches</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.localization_and_regex_traits">Localization and Regex Traits</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.tips_n_tricks"> Tips 'N Tricks</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.concepts">Concepts</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.examples">Examples</a></span></dt>
</dl></div>
<p>
      This section describes how to use xpressive to accomplish text manipulation
      and parsing tasks. If you are looking for detailed information regarding specific
      components in xpressive, check the <a href="reference.html" title="Reference">Reference</a>
      section.
    </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.user_s_guide.introduction"></a>Introduction</h3></div></div></div>
<a name="boost_xpressive.user_s_guide.introduction.what_is_xpressive_"></a><h2>
<a name="id1953765"></a>
        What is xpressive?
      </h2>
<p>
        xpressive is an object-oriented regular expression library. Regular expressions
        (regexes) can be written as strings that are parsed dynamically at runtime
        (dynamic regexes), or as expression templates that are parsed at compile-time
        (static regexes). Dynamic regexes have the advantage that they can be accepted
        from the user as input at runtime or read from an initialization file. Static
        regexes have several advantages. Since they are C++ expressions instead of
        strings, they can be syntax-checked at compile-time. Also, they can refer
        to other regexes and to themselves, giving static regexes the power of context-free
        grammars. Finally, since they are statically bound, the compiler can generate
        faster code for static regexes.
      </p>
<p>
        xpressive's dual nature is unique and powerful. Static xpressive is a bit
        like the <a href="http://spirit.sourceforge.net" target="_top">Spirit Parser Framework</a>.
        Like <a href="http://spirit.sourceforge.net" target="_top">Spirit</a>, you can build
        grammars with static regexes using expression templates. (Unlike <a href="http://spirit.sourceforge.net" target="_top">Spirit</a>,
        xpressive does exhaustive backtracking, trying every possibility to find
        a match for your pattern.) Dynamic xpressive is a bit like <a href="../../../libs/regex" target="_top">Boost.Regex</a>.
        In fact, xpressive's interface should be familiar to anyone who has used
        <a href="../../../libs/regex" target="_top">Boost.Regex</a>. xpressive's innovation
        comes from allowing you to mix and match static and dynamic regexes in the
        same program, and even in the same expression! You can embed a dynamic regex
        in a static regex, and the dynamic regex will participate fully in the search,
        back-tracking as needed to make the match succeed.
      </p>
<a name="boost_xpressive.user_s_guide.introduction.hello__world_"></a><h2>
<a name="id1953828"></a>
        Hello, world!
      </h2>
<p>
        Enough theory. Let's have a look at <span class="emphasis"><em>Hello World</em></span>, xpressive
        style:
      </p>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">hello</span><span class="special">(</span> <span class="string">"hello world!"</span> <span class="special">);</span>

    <span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"(\\w+) (\\w+)!"</span> <span class="special">);</span>
    <span class="identifier">smatch</span> <span class="identifier">what</span><span class="special">;</span>

    <span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="identifier">hello</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">rex</span> <span class="special">)</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// whole match
</span>        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// first capture
</span>        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">2</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// second capture
</span>    <span class="special">}</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        This program outputs the following:
      </p>
<pre class="programlisting">hello world!
hello
world
</pre>
<p>
        The first thing you'll notice about the code is that all the types in xpressive
        live in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span></code> namespace.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          Most of the rest of the examples in this document will leave off the <code class="computeroutput"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span></code>
          directive. Just pretend it's there.
        </p></td></tr>
</table></div>
<p>
        Next, you'll notice the type of the regular expression object is <code class="computeroutput"><span class="identifier">sregex</span></code>. If you are familiar with <a href="../../../libs/regex" target="_top">Boost.Regex</a>, this is different than what you
        are used to. The "<code class="computeroutput"><span class="identifier">s</span></code>"
        in "<code class="computeroutput"><span class="identifier">sregex</span></code>" stands
        for "<code class="computeroutput"><span class="identifier">string</span></code>", indicating
        that this regex can be used to find patterns in <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
        objects. I'll discuss this difference and its implications in detail later.
      </p>
<p>
        Notice how the regex object is initialized:
      </p>
<pre class="programlisting">
<span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"(\\w+) (\\w+)!"</span> <span class="special">);</span>
</pre>
<p>
        To create a regular expression object from a string, you must call a factory
        method such as <code class="literal"><code class="computeroutput">basic_regex::compile()</code></code>.
        This is another area in which xpressive differs from other object-oriented
        regular expression libraries. Other libraries encourage you to think of a
        regular expression as a kind of string on steroids. In xpressive, regular
        expressions are not strings; they are little programs in a domain-specific
        language. Strings are only one <span class="emphasis"><em>representation</em></span> of that
        language. Another representation is an expression template. For example,
        the above line of code is equivalent to the following:
      </p>
<pre class="programlisting">
<span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">s1</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">' '</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s2</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'!'</span><span class="special">;</span>
</pre>
<p>
        This describes the same regular expression, except it uses the domain-specific
        embedded language defined by static xpressive.
      </p>
<p>
        As you can see, static regexes have a syntax that is noticeably different
        than standard Perl syntax. That is because we are constrained by C++'s syntax.
        The biggest difference is the use of <code class="computeroutput"><span class="special">&gt;&gt;</span></code>
        to mean "followed by". For instance, in Perl you can just put sub-expressions
        next to each other:
      </p>
<pre class="programlisting">
<span class="identifier">abc</span>
</pre>
<p>
        But in C++, there must be an operator separating sub-expressions:
      </p>
<pre class="programlisting">
<span class="identifier">a</span> <span class="special">&gt;&gt;</span> <span class="identifier">b</span> <span class="special">&gt;&gt;</span> <span class="identifier">c</span>
</pre>
<p>
        In Perl, parentheses <code class="computeroutput"><span class="special">()</span></code> have
        special meaning. They group, but as a side-effect they also create back-references
        like <code class="literal">$1</code> and <code class="literal">$2</code>. In C++, there is no
        way to overload parentheses to give them side-effects. To get the same effect,
        we use the special <code class="computeroutput"><span class="identifier">s1</span></code>, <code class="computeroutput"><span class="identifier">s2</span></code>, etc. tokens. Assign to one to create
        a back-reference (known as a sub-match in xpressive).
      </p>
<p>
        You'll also notice that the one-or-more repetition operator <code class="computeroutput"><span class="special">+</span></code> has moved from postfix to prefix position.
        That's because C++ doesn't have a postfix <code class="computeroutput"><span class="special">+</span></code>
        operator. So:
      </p>
<pre class="programlisting">
<span class="string">"\\w+"</span>
</pre>
<p>
        is the same as:
      </p>
<pre class="programlisting">
<span class="special">+</span><span class="identifier">_w</span>
</pre>
<p>
        We'll cover all the other differences <a href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes" title="Static Regexes">later</a>.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.user_s_guide.installing_xpressive"></a>Installing xpressive</h3></div></div></div>
<a name="boost_xpressive.user_s_guide.installing_xpressive.getting_xpressive"></a><h2>
<a name="id1954868"></a>
        Getting xpressive
      </h2>
<p>
        There are two ways to get xpressive. The first is by downloading xpressive.zip
        at the <a href="http://www.boost-consulting.com/vault/index.php?directory=Strings%20-%20Text%20Processing" target="_top">Boost
        File Vault</a> in the "Strings - Text Processing" directory.
        In addition to the source code and the Boost license, this archive contains
        a copy of this documentation in PDF format.
      </p>
<p>
        The second way is through anonymous CVS via the boost project on SourceForge.net.
        Just go to <a href="http://sf.net/projects/boost" target="_top">http://sf.net/projects/boost</a>
        and follow the instructions there for anonymous CVS access.
      </p>
<a name="boost_xpressive.user_s_guide.installing_xpressive.building_with_xpressive"></a><h2>
<a name="id1954910"></a>
        Building with xpressive
      </h2>
<p>
        xpressive is a header-only template library, which means you don't need to
        alter your build scripts or link to any separate lib file to use it. All
        you need to do is <code class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>.
        If you are only using static regexes, you can improve compile times by only
        including <code class="computeroutput"><span class="identifier">xpressive_static</span><span class="special">.</span><span class="identifier">hpp</span></code>. Likewise,
        you can include <code class="computeroutput"><span class="identifier">xpressive_dynamic</span><span class="special">.</span><span class="identifier">hpp</span></code> if
        you only plan on using dynamic regexes.
      </p>
<a name="boost_xpressive.user_s_guide.installing_xpressive.requirements"></a><h2>
<a name="id1954905"></a>
        Requirements
      </h2>
<p>
        xpressive depends on Boost. You can download the latest version of the Boost
        libraries from <a href="http://boost.org" target="_top">http://boost.org</a>. xpressive
        requires Boost version 1.32 or higher.
      </p>
<a name="boost_xpressive.user_s_guide.installing_xpressive.supported_compilers"></a><h2>
<a name="id1955046"></a>
        Supported Compilers
      </h2>
<p>
        Currently, Boost.Xpressive is known to work on the following compilers:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          Visual C++ 7.1 and higher
        </li>
<li>
          GNU C++ 3.2 and higher
        </li>
<li>
          Intel for Linux 8.1 and higher
        </li>
<li>
          Intel for Windows 8.1 and higher
        </li>
<li>
          tru64cxx 65 and higher
        </li>
<li>
          QNX qcc 3.3 and higher
        </li>
<li>
          MinGW 3.4 and higher
        </li>
<li>
          Metrowerks CodeWarrior 9.4 and higher
        </li>
</ul></div>
<p>
        Check the latest tests results at Boost's <a href="http://engineering.meta-comm.com/boost-regression/CVS-HEAD/developer/xpressive.html" target="_top">Regression
        Results Page</a>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          Please send any questions, comments and bug reports to eric &lt;at&gt;
          boost-consulting &lt;dot&gt; com.
        </p></td></tr>
</table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.user_s_guide.quick_start"></a>Quick Start</h3></div></div></div>
<p>
        You don't need to know much to start being productive with xpressive. Let's
        begin with the nickel tour of the types and algorithms xpressive provides.
      </p>
<div class="informaltable">
<h4>
<a name="id1955134"></a>
          <span class="table-title">xpressive's Tool-Box</span>
        </h4>
<table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>Tool</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code></td>
<td>Contains
              a compiled regular expression. <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
              is the most important type in xpressive. Everything you do with xpressive
              will begin with creating an object of type <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>.</td>
</tr>
<tr>
<td>
<code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>,
              <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
</td>
<td>
<code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
              contains the results of a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
              or <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
              operation. It acts like a vector of <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
              objects. A <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
              object contains a marked sub-expression (also known as a back-reference
              in Perl). It is basically just a pair of iterators representing the
              begin and end of the marked sub-expression.</td>
</tr>
<tr>
<td><code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code></td>
<td>Checks
              to see if a string matches a regex. For <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
              to succeed, the <span class="emphasis"><em>whole string</em></span> must match the regex,
              from beginning to end. If you give <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
              a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>,
              it will write into it any marked sub-expressions it finds.</td>
</tr>
<tr>
<td><code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code></td>
<td>Searches
              a string to find a sub-string that matches the regex. <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
              will try to find a match at every position in the string, starting
              at the beginning, and stopping when it finds a match or when the string
              is exhausted. As with <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>,
              if you give <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
              a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>,
              it will write into it any marked sub-expressions it finds.</td>
</tr>
<tr>
<td><code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code></td>
<td>Given
              an input string, a regex, and a substitution string, <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
              builds a new string by replacing those parts of the input string that
              match the regex with the substitution string. The substitution string
              can contain references to marked sub-expressions.</td>
</tr>
<tr>
<td><code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code></td>
<td>An
              STL-compatible iterator that makes it easy to find all the places in
              a string that match a regex. Dereferencing a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>
              returns a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>.
              Incrementing a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>
              finds the next match.</td>
</tr>
<tr>
<td><code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code></td>
<td>Like
              <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>,
              except dereferencing a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
              returns a string. By default, it will return the whole sub-string that
              the regex matched, but it can be configured to return any or all of
              the marked sub-expressions one at a time, or even the parts of the
              string that <span class="emphasis"><em>didn't</em></span> match the regex.</td>
</tr>
<tr>
<td><code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code></td>
<td>A
              factory for <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
              objects. It "compiles" a string into a regular expression.
              You will not usually have to deal directly with <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
              because the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
              class has a factory method that uses <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
              internally. But if you need to do anything fancy like create a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
              object with a different <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>,
              you will need to use a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
              explicitly.</td>
</tr>
</tbody>
</table>
</div>
<p>
        Now that you know a bit about the tools xpressive provides, you can pick
        the right tool for you by answering the following two questions:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          What <span class="emphasis"><em>iterator</em></span> type will you use to traverse your data?
        </li>
<li>
          What do you want to <span class="emphasis"><em>do</em></span> to your data?
        </li>
</ol></div>
<a name="boost_xpressive.user_s_guide.quick_start.know_your_iterator_type"></a><h2>
<a name="id1955823"></a>
        Know Your Iterator Type
      </h2>
<p>
        Most of the classes in xpressive are templates that are parameterized on
        the iterator type. xpressive defines some common typedefs to make the job
        of choosing the right types easier. You can use the table below to find the
        right types based on the type of your iterator.
      </p>
<div class="informaltable">
<h4>
<a name="id1955841"></a>
          <span class="table-title">xpressive Typedefs vs. Iterator Types</span>
        </h4>
<table class="table">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th> </th>
<th>std::string::const_iterator</th>
<th>char
              const *</th>
<th>std::wstring::const_iterator</th>
<th>wchar_t
              const *</th>
</tr></thead>
<tbody>
<tr>
<td><code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code></td>
<td><code class="computeroutput"><span class="identifier">sregex</span></code></td>
<td><code class="computeroutput"><span class="identifier">cregex</span></code></td>
<td><code class="computeroutput"><span class="identifier">wsregex</span></code></td>
<td><code class="computeroutput"><span class="identifier">wcregex</span></code></td>
</tr>
<tr>
<td><code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code></td>
<td><code class="computeroutput"><span class="identifier">smatch</span></code></td>
<td><code class="computeroutput"><span class="identifier">cmatch</span></code></td>
<td><code class="computeroutput"><span class="identifier">wsmatch</span></code></td>
<td><code class="computeroutput"><span class="identifier">wcmatch</span></code></td>
</tr>
<tr>
<td><code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code></td>
<td><code class="computeroutput"><span class="identifier">sregex_compiler</span></code></td>
<td><code class="computeroutput"><span class="identifier">cregex_compiler</span></code></td>
<td><code class="computeroutput"><span class="identifier">wsregex_compiler</span></code></td>
<td><code class="computeroutput"><span class="identifier">wcregex_compiler</span></code></td>
</tr>
<tr>
<td><code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code></td>
<td><code class="computeroutput"><span class="identifier">sregex_iterator</span></code></td>
<td><code class="computeroutput"><span class="identifier">cregex_iterator</span></code></td>
<td><code class="computeroutput"><span class="identifier">wsregex_iterator</span></code></td>
<td><code class="computeroutput"><span class="identifier">wcregex_iterator</span></code></td>
</tr>
<tr>
<td><code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code></td>
<td><code class="computeroutput"><span class="identifier">sregex_token_iterator</span></code></td>
<td><code class="computeroutput"><span class="identifier">cregex_token_iterator</span></code></td>
<td><code class="computeroutput"><span class="identifier">wsregex_token_iterator</span></code></td>
<td><code class="computeroutput"><span class="identifier">wcregex_token_iterator</span></code></td>
</tr>
</tbody>
</table>
</div>
<p>
        You should notice the systematic naming convention. Many of these types are
        used together, so the naming convention helps you to use them consistently.
        For instance, if you have a <code class="computeroutput"><span class="identifier">sregex</span></code>,
        you should also be using a <code class="computeroutput"><span class="identifier">smatch</span></code>.
      </p>
<p>
        If you are not using one of those four iterator types, then you can use the
        templates directly and specify your iterator type.
      </p>
<a name="boost_xpressive.user_s_guide.quick_start.know_your_task"></a><h2>
<a name="id1956188"></a>
        Know Your Task
      </h2>
<p>
        Do you want to find a pattern once? Many times? Search and replace? xpressive
        has tools for all that and more. Below is a quick reference:
      </p>
<div class="informaltable">
<h4>
<a name="id1956204"></a>
          <span class="table-title">Tasks and Tools</span>
        </h4>
<table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>To do this ...</th>
<th>Use this ...</th>
</tr></thead>
<tbody>
<tr>
<td>
<span class="inlinemediaobject"><img src="../images/tip.png" alt="tip"></span> <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples.see_if_a_whole_string_matches_a_regex">See
              if a whole string matches a regex</a>
</td>
<td>The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
              algorithm</td>
</tr>
<tr>
<td>
<span class="inlinemediaobject"><img src="../images/tip.png" alt="tip"></span> <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples.see_if_a_string_contains_a_sub_string_that_matches_a_regex">See
              if a string contains a sub-string that matches a regex</a>
</td>
<td>The
              <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
              algorithm</td>
</tr>
<tr>
<td>
<span class="inlinemediaobject"><img src="../images/tip.png" alt="tip"></span> <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples.replace_all_sub_strings_that_match_a_regex">Replace
              all sub-strings that match a regex</a>
</td>
<td>The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
              algorithm</td>
</tr>
<tr>
<td>
<span class="inlinemediaobject"><img src="../images/tip.png" alt="tip"></span> <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples.find_all_the_sub_strings_that_match_a_regex_and_step_through_them_one_at_a_time">Find
              all the sub-strings that match a regex and step through them one at
              a time</a>
</td>
<td>The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_iterator.html" title="Struct template regex_iterator">regex_iterator&lt;&gt;</a></code></code>
              class</td>
</tr>
<tr>
<td>
<span class="inlinemediaobject"><img src="../images/tip.png" alt="tip"></span> <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples.split_a_string_into_tokens_that_each_match_a_regex">Split
              a string into tokens that each match a regex</a>
</td>
<td>The
              <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
              class</td>
</tr>
<tr>
<td>
<span class="inlinemediaobject"><img src="../images/tip.png" alt="tip"></span> <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples.split_a_string_using_a_regex_as_a_delimiter">Split
              a string using a regex as a delimiter</a>
</td>
<td>The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
              class</td>
</tr>
</tbody>
</table>
</div>
<p>
        These algorithms and classes are described in excruciating detail in the
        Reference section.
      </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          Try clicking on a task in the table above to see a complete example program
          that uses xpressive to solve that particular task.
        </p></td></tr>
</table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="xpressive.user_s_guide.creating_a_regex_object"></a>Creating a Regex Object</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes">Static Regexes</a></span></dt>
<dt><span class="section"><a href="user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes">Dynamic Regexes</a></span></dt>
</dl></div>
<p>
        When using xpressive, the first thing you'll do is create a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
        object. This section goes over the nuts and bolts of building a regular expression
        in the two dialects xpressive supports: static and dynamic.
      </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes"></a>Static Regexes</h4></div></div></div>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.overview"></a><h2>
<a name="id1956588"></a>
          Overview
        </h2>
<p>
          The feature that really sets xpressive apart from other C/C++ regular expression
          libraries is the ability to author a regular expression using C++ expressions.
          xpressive achieves this through operator overloading, using a technique
          called <span class="emphasis"><em>expression templates</em></span> to embed a mini-language
          dedicated to pattern matching within C++. These "static regexes"
          have many advantages over their string-based brethren. In particular, static
          regexes:
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            are syntax-checked at compile-time; they will never fail at run-time
            due to a syntax error.
          </li>
<li>
            can naturally refer to other C++ data and code, including other regexes,
            making it possible to build grammars out of regular expressions and bind
            user-defined actions that execute when parts of your regex match.
          </li>
<li>
            are statically bound for better inlining and optimization. Static regexes
            require no state tables, virtual functions, byte-code or calls through
            function pointers that cannot be resolved at compile time.
          </li>
<li>
            are not limited to searching for patterns in strings. You can declare
            a static regex that finds patterns in an array of integers, for instance.
          </li>
</ul></div>
<p>
          Since we compose static regexes using C++ expressions, we are constrained
          by the rules for legal C++ expressions. Unfortunately, that means that
          "classic" regular expression syntax cannot always be mapped cleanly
          into C++. Rather, we map the regex <span class="emphasis"><em>constructs</em></span>, picking
          new syntax that is legal C++.
        </p>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.construction_and_assignment"></a><h2>
<a name="id1956662"></a>
          Construction and Assignment
        </h2>
<p>
          You create a static regex by assigning one to an object of type <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>.
          For instance, the following defines a regex that can be used to find patterns
          in objects of type <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>:
        </p>
<pre class="programlisting">
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="char">'$'</span> <span class="special">&gt;&gt;</span> <span class="special">+</span><span class="identifier">_d</span> <span class="special">&gt;&gt;</span> <span class="char">'.'</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span><span class="special">;</span>
</pre>
<p>
          Assignment works similarly.
        </p>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.character_and_string_literals"></a><h2>
<a name="id1956798"></a>
          Character and String Literals
        </h2>
<p>
          In static regexes, character and string literals match themselves. For
          instance, in the regex above, <code class="computeroutput"><span class="char">'$'</span></code>
          and <code class="computeroutput"><span class="char">'.'</span></code> match the characters
          <code class="computeroutput"><span class="char">'$'</span></code> and <code class="computeroutput"><span class="char">'.'</span></code>
          respectively. Don't be confused by the fact that <code class="literal">$</code> and
          <code class="literal">.</code> are meta-characters in Perl. In xpressive, literals
          always represent themselves.
        </p>
<p>
          When using literals in static regexes, you must take care that at least
          one operand is not a literal. For instance, the following are <span class="emphasis"><em>not</em></span>
          valid regexes:
        </p>
<pre class="programlisting">
<span class="identifier">sregex</span> <span class="identifier">re1</span> <span class="special">=</span> <span class="char">'a'</span> <span class="special">&gt;&gt;</span> <span class="char">'b'</span><span class="special">;</span>         <span class="comment">// ERROR!
</span><span class="identifier">sregex</span> <span class="identifier">re2</span> <span class="special">=</span> <span class="special">+</span><span class="char">'a'</span><span class="special">;</span>               <span class="comment">// ERROR!
</span></pre>
<p>
          The two operands to the binary <code class="computeroutput"><span class="special">&gt;&gt;</span></code>
          operator are both literals, and the operand of the unary <code class="computeroutput"><span class="special">+</span></code> operator is also a literal, so these statements
          will call the native C++ binary right-shift and unary plus operators, respectively.
          That's not what we want. To get operator overloading to kick in, at least
          one operand must be a user-defined type. We can use xpressive's <code class="computeroutput"><span class="identifier">as_xpr</span><span class="special">()</span></code>
          helper function to "taint" an expression with regex-ness, forcing
          operator overloading to find the correct operators. The two regexes above
          should be written as:
        </p>
<pre class="programlisting">
<span class="identifier">sregex</span> <span class="identifier">re1</span> <span class="special">=</span> <span class="identifier">as_xpr</span><span class="special">(</span><span class="char">'a'</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'b'</span><span class="special">;</span> <span class="comment">// OK
</span><span class="identifier">sregex</span> <span class="identifier">re2</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">as_xpr</span><span class="special">(</span><span class="char">'a'</span><span class="special">);</span>       <span class="comment">// OK
</span></pre>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.sequencing_and_alternation"></a><h2>
<a name="id1957107"></a>
          Sequencing and Alternation
        </h2>
<p>
          As you've probably already noticed, sub-expressions in static regexes must
          be separated by the sequencing operator, <code class="computeroutput"><span class="special">&gt;&gt;</span></code>.
          You can read this operator as "followed by".
        </p>
<pre class="programlisting">
<span class="comment">// Match an 'a' followed by a digit
</span><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="char">'a'</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span><span class="special">;</span>
</pre>
<p>
          Alternation works just as it does in Perl with the <code class="computeroutput"><span class="special">|</span></code>
          operator. You can read this operator as "or". For example:
        </p>
<pre class="programlisting">
<span class="comment">// match a digit character or a word character one or more times
</span><span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="special">+(</span> <span class="identifier">_d</span> <span class="special">|</span> <span class="identifier">_w</span> <span class="special">);</span>
</pre>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.grouping_and_captures"></a><h2>
<a name="id1957253"></a>
          Grouping and Captures
        </h2>
<p>
          In Perl, parentheses <code class="computeroutput"><span class="special">()</span></code> have
          special meaning. They group, but as a side-effect they also create back-references
          like <code class="literal">$1</code> and <code class="literal">$2</code>. In C++, parentheses
          only group -- there is no way to give them side-effects. To get the same
          effect, we use the special <code class="computeroutput"><span class="identifier">s1</span></code>,
          <code class="computeroutput"><span class="identifier">s2</span></code>, etc. tokens. Assigning
          to one creates a back-reference. You can then use the back-reference later
          in your expression, like using <code class="literal">\1</code> and <code class="literal">\2</code>
          in Perl. For example, consider the following regex, which finds matching
          HTML tags:
        </p>
<pre class="programlisting">
<span class="string">"&lt;(\\w+)&gt;.*?&lt;/\\1&gt;"</span>
</pre>
<p>
          In static xpressive, this would be:
        </p>
<pre class="programlisting">
<span class="char">'&lt;'</span> <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">s1</span><span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">'&gt;'</span> <span class="special">&gt;&gt;</span> <span class="special">-*</span><span class="identifier">_</span> <span class="special">&gt;&gt;</span> <span class="string">"&lt;/"</span> <span class="special">&gt;&gt;</span> <span class="identifier">s1</span> <span class="special">&gt;&gt;</span> <span class="char">'&gt;'</span>
</pre>
<p>
          Notice how you capture a back-reference by assigning to <code class="computeroutput"><span class="identifier">s1</span></code>,
          and then you use <code class="computeroutput"><span class="identifier">s1</span></code> later
          in the pattern to find the matching end tag.
        </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
            <span class="bold"><strong>Grouping without capturing a back-reference</strong></span> <br>
            <br> In xpressive, if you just want grouping without capturing a back-reference,
            you can just use <code class="computeroutput"><span class="special">()</span></code> without
            <code class="computeroutput"><span class="identifier">s1</span></code>. That is the equivalent
            of Perl's <code class="literal">(?:)</code> non-capturing grouping construct.
          </p></td></tr>
</table></div>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.case_insensitivity_and_internationalization"></a><h2>
<a name="id1974992"></a>
          Case-Insensitivity and Internationalization
        </h2>
<p>
          Perl lets you make part of your regular expression case-insensitive by
          using the <code class="literal">(?i:)</code> pattern modifier. xpressive also has
          a case-insensitivity pattern modifier, called <code class="computeroutput"><span class="identifier">icase</span></code>.
          You can use it as follows:
        </p>
<pre class="programlisting">
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="string">"this"</span> <span class="special">&gt;&gt;</span> <span class="identifier">icase</span><span class="special">(</span> <span class="string">"that"</span> <span class="special">);</span>
</pre>
<p>
          In this regular expression, <code class="computeroutput"><span class="string">"this"</span></code>
          will be matched exactly, but <code class="computeroutput"><span class="string">"that"</span></code>
          will be matched irrespective of case.
        </p>
<p>
          Case-insensitive regular expressions raise the issue of internationalization:
          how should case-insensitive character comparisons be evaluated? Also, many
          character classes are locale-specific. Which characters are matched by
          <code class="computeroutput"><span class="identifier">digit</span></code> and which are matched
          by <code class="computeroutput"><span class="identifier">alpha</span></code>? The answer depends
          on the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code> object the regular expression
          object is using. By default, all regular expression objects use the global
          locale. You can override the default by using the <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code> pattern modifier, as follows:
        </p>
<pre class="programlisting">
<span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span> <span class="identifier">my_locale</span> <span class="special">=</span> <span class="comment">/* initialize a std::locale object */</span><span class="special">;</span>
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">imbue</span><span class="special">(</span> <span class="identifier">my_locale</span> <span class="special">)(</span> <span class="special">+</span><span class="identifier">alpha</span> <span class="special">&gt;&gt;</span> <span class="special">+</span><span class="identifier">digit</span> <span class="special">);</span>
</pre>
<p>
          This regular expression will evaluate <code class="computeroutput"><span class="identifier">alpha</span></code>
          and <code class="computeroutput"><span class="identifier">digit</span></code> according to
          <code class="computeroutput"><span class="identifier">my_locale</span></code>. See the section
          on <a href="user_s_guide.html#boost_xpressive.user_s_guide.localization_and_regex_traits" title="Localization and Regex Traits">Localization
          and Regex Traits</a> for more information about how to customize the
          behavior of your regexes.
        </p>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.static_xpressive_syntax_cheat_sheet"></a><h2>
<a name="id1975320"></a>
          Static xpressive Syntax Cheat Sheet
        </h2>
<p>
          The table below lists the familiar regex constructs and their equivalents
          in static xpressive.
        </p>
<div class="informaltable">
<h4>
<a name="id1975336"></a>
            <span class="table-title">Perl syntax vs. Static xpressive syntax</span>
          </h4>
<table class="table">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Perl</th>
<th>Static xpressive</th>
<th>Meaning</th>
</tr></thead>
<tbody>
<tr>
<td><code class="literal">.</code></td>
<td><code class="computeroutput"><span class="identifier">_</span></code></td>
<td>any
                character (assuming Perl's /s modifier).</td>
</tr>
<tr>
<td><code class="literal">ab</code></td>
<td><code class="computeroutput"><span class="identifier">a</span> <span class="special">&gt;&gt;</span> <span class="identifier">b</span></code></td>
<td>sequencing
                of <code class="literal">a</code> and <code class="literal">b</code> sub-expressions.</td>
</tr>
<tr>
<td><code class="literal">a|b</code></td>
<td><code class="computeroutput"><span class="identifier">a</span> <span class="special">|</span> <span class="identifier">b</span></code></td>
<td>alternation
                of <code class="literal">a</code> and <code class="literal">b</code> sub-expressions.</td>
</tr>
<tr>
<td><code class="literal">(a)</code></td>
<td><code class="computeroutput"><span class="special">(</span><span class="identifier">s1</span><span class="special">=</span> <span class="identifier">a</span><span class="special">)</span></code></td>
<td>group
                and capture a back-reference.</td>
</tr>
<tr>
<td><code class="literal">(?:a)</code></td>
<td><code class="computeroutput"><span class="special">(</span><span class="identifier">a</span><span class="special">)</span></code></td>
<td>group
                and do not capture a back-reference.</td>
</tr>
<tr>
<td><code class="literal">\1</code></td>
<td><code class="computeroutput"><span class="identifier">s1</span></code></td>
<td>a
                previously captured back-reference.</td>
</tr>
<tr>
<td><code class="literal">a*</code></td>
<td><code class="computeroutput"><span class="special">*</span><span class="identifier">a</span></code></td>
<td>zero or more times,
                greedy.</td>
</tr>
<tr>
<td><code class="literal">a+</code></td>
<td><code class="computeroutput"><span class="special">+</span><span class="identifier">a</span></code></td>
<td>one or more times,
                greedy.</td>
</tr>
<tr>
<td><code class="literal">a?</code></td>
<td><code class="computeroutput"><span class="special">!</span><span class="identifier">a</span></code></td>
<td>zero or one time,
                greedy.</td>
</tr>
<tr>
<td><code class="literal">a{n,m}</code></td>
<td><code class="computeroutput"><span class="identifier">repeat</span><span class="special">&lt;</span><span class="identifier">n</span><span class="special">,</span><span class="identifier">m</span><span class="special">&gt;(</span><span class="identifier">a</span><span class="special">)</span></code></td>
<td>between <code class="literal">n</code>
                and <code class="literal">m</code> times, greedy.</td>
</tr>
<tr>
<td><code class="literal">a*?</code></td>
<td><code class="computeroutput"><span class="special">-*</span><span class="identifier">a</span></code></td>
<td>zero or more times,
                non-greedy.</td>
</tr>
<tr>
<td><code class="literal">a+?</code></td>
<td><code class="computeroutput"><span class="special">-+</span><span class="identifier">a</span></code></td>
<td>one or more times,
                non-greedy.</td>
</tr>
<tr>
<td><code class="literal">a??</code></td>
<td><code class="computeroutput"><span class="special">-!</span><span class="identifier">a</span></code></td>
<td>zero or one time,
                non-greedy.</td>
</tr>
<tr>
<td><code class="literal">a{n,m}?</code></td>
<td><code class="computeroutput"><span class="special">-</span><span class="identifier">repeat</span><span class="special">&lt;</span><span class="identifier">n</span><span class="special">,</span><span class="identifier">m</span><span class="special">&gt;(</span><span class="identifier">a</span><span class="special">)</span></code></td>
<td>between
                <code class="literal">n</code> and <code class="literal">m</code> times, non-greedy.</td>
</tr>
<tr>
<td><code class="literal">^</code></td>
<td><code class="computeroutput"><span class="identifier">bos</span></code></td>
<td>beginning
                of sequence assertion.</td>
</tr>
<tr>
<td><code class="literal">$</code></td>
<td><code class="computeroutput"><span class="identifier">eos</span></code></td>
<td>end
                of sequence assertion.</td>
</tr>
<tr>
<td><code class="literal">\b</code></td>
<td><code class="computeroutput"><span class="identifier">_b</span></code></td>
<td>word
                boundary assertion.</td>
</tr>
<tr>
<td><code class="literal">\B</code></td>
<td><code class="computeroutput"><span class="special">~</span><span class="identifier">_b</span></code></td>
<td>not word boundary
                assertion.</td>
</tr>
<tr>
<td><code class="literal">\n</code></td>
<td><code class="computeroutput"><span class="identifier">_n</span></code></td>
<td>literal
                newline.</td>
</tr>
<tr>
<td><code class="literal">.</code></td>
<td><code class="computeroutput"><span class="special">~</span><span class="identifier">_n</span></code></td>
<td>any character
                except a literal newline (without Perl's /s modifier).</td>
</tr>
<tr>
<td><code class="literal">\r?\n|\r</code></td>
<td><code class="computeroutput"><span class="identifier">_ln</span></code></td>
<td>logical
                newline.</td>
</tr>
<tr>
<td><code class="literal">[^\r\n]</code></td>
<td><code class="computeroutput"><span class="special">~</span><span class="identifier">_ln</span></code></td>
<td>any single character
                not a logical newline.</td>
</tr>
<tr>
<td><code class="literal">\w</code></td>
<td><code class="computeroutput"><span class="identifier">_w</span></code></td>
<td>a
                word character, equivalent to set[alnum | '_'].</td>
</tr>
<tr>
<td><code class="literal">\W</code></td>
<td><code class="computeroutput"><span class="special">~</span><span class="identifier">_w</span></code></td>
<td>not a word character,
                equivalent to ~set[alnum | '_'].</td>
</tr>
<tr>
<td><code class="literal">\d</code></td>
<td><code class="computeroutput"><span class="identifier">_d</span></code></td>
<td>a
                digit character.</td>
</tr>
<tr>
<td><code class="literal">\D</code></td>
<td><code class="computeroutput"><span class="special">~</span><span class="identifier">_d</span></code></td>
<td>not a digit character.</td>
</tr>
<tr>
<td><code class="literal">\s</code></td>
<td><code class="computeroutput"><span class="identifier">_s</span></code></td>
<td>a
                space character.</td>
</tr>
<tr>
<td><code class="literal">\S</code></td>
<td><code class="computeroutput"><span class="special">~</span><span class="identifier">_s</span></code></td>
<td>not a space character.</td>
</tr>
<tr>
<td><code class="literal">[:alnum:]</code></td>
<td><code class="computeroutput"><span class="identifier">alnum</span></code></td>
<td>an
                alpha-numeric character.</td>
</tr>
<tr>
<td><code class="literal">[:alpha:]</code></td>
<td><code class="computeroutput"><span class="identifier">alpha</span></code></td>
<td>an
                alphabetic character.</td>
</tr>
<tr>
<td><code class="literal">[:blank:]</code></td>
<td><code class="computeroutput"><span class="identifier">blank</span></code></td>
<td>a
                horizontal white-space character.</td>
</tr>
<tr>
<td><code class="literal">[:cntrl:]</code></td>
<td><code class="computeroutput"><span class="identifier">cntrl</span></code></td>
<td>a
                control character.</td>
</tr>
<tr>
<td><code class="literal">[:digit:]</code></td>
<td><code class="computeroutput"><span class="identifier">digit</span></code></td>
<td>a
                digit character.</td>
</tr>
<tr>
<td><code class="literal">[:graph:]</code></td>
<td><code class="computeroutput"><span class="identifier">graph</span></code></td>
<td>a
                graphable character.</td>
</tr>
<tr>
<td><code class="literal">[:lower:]</code></td>
<td><code class="computeroutput"><span class="identifier">lower</span></code></td>
<td>a
                lower-case character.</td>
</tr>
<tr>
<td><code class="literal">[:print:]</code></td>
<td><code class="computeroutput"><span class="identifier">print</span></code></td>
<td>a
                printing character.</td>
</tr>
<tr>
<td><code class="literal">[:punct:]</code></td>
<td><code class="computeroutput"><span class="identifier">punct</span></code></td>
<td>a
                punctuation character.</td>
</tr>
<tr>
<td><code class="literal">[:space:]</code></td>
<td><code class="computeroutput"><span class="identifier">space</span></code></td>
<td>a
                white-space character.</td>
</tr>
<tr>
<td><code class="literal">[:upper:]</code></td>
<td><code class="computeroutput"><span class="identifier">upper</span></code></td>
<td>an
                upper-case character.</td>
</tr>
<tr>
<td><code class="literal">[:xdigit:]</code></td>
<td><code class="computeroutput"><span class="identifier">xdigit</span></code></td>
<td>a hexadecimal
                digit character.</td>
</tr>
<tr>
<td><code class="literal">[0-9]</code></td>
<td><code class="computeroutput"><span class="identifier">range</span><span class="special">(</span><span class="char">'0'</span><span class="special">,</span><span class="char">'9'</span><span class="special">)</span></code></td>
<td>characters in range
                <code class="computeroutput"><span class="char">'0'</span></code> through <code class="computeroutput"><span class="char">'9'</span></code>.</td>
</tr>
<tr>
<td><code class="literal">[abc]</code></td>
<td><code class="computeroutput"><span class="identifier">as_xpr</span><span class="special">(</span><span class="char">'a'</span><span class="special">)</span> <span class="special">|</span> <span class="char">'b'</span> <span class="special">|</span><span class="char">'c'</span></code></td>
<td>characters <code class="computeroutput"><span class="char">'a'</span></code>, <code class="computeroutput"><span class="char">'b'</span></code>,
                or <code class="computeroutput"><span class="char">'c'</span></code>.</td>
</tr>
<tr>
<td><code class="literal">[abc]</code></td>
<td><code class="computeroutput"><span class="special">(</span><span class="identifier">set</span><span class="special">=</span> <span class="char">'a'</span><span class="special">,</span><span class="char">'b'</span><span class="special">,</span><span class="char">'c'</span><span class="special">)</span></code></td>
<td><span class="emphasis"><em>same
                as above</em></span></td>
</tr>
<tr>
<td><code class="literal">[0-9abc]</code></td>
<td><code class="computeroutput"><span class="identifier">set</span><span class="special">[</span> <span class="identifier">range</span><span class="special">(</span><span class="char">'0'</span><span class="special">,</span><span class="char">'9'</span><span class="special">)</span> <span class="special">|</span> <span class="char">'a'</span> <span class="special">|</span> <span class="char">'b'</span> <span class="special">|</span> <span class="char">'c'</span> <span class="special">]</span></code></td>
<td>characters
                <code class="computeroutput"><span class="char">'a'</span></code>, <code class="computeroutput"><span class="char">'b'</span></code>,
                <code class="computeroutput"><span class="char">'c'</span></code> or in range <code class="computeroutput"><span class="char">'0'</span></code> through <code class="computeroutput"><span class="char">'9'</span></code>.</td>
</tr>
<tr>
<td><code class="literal">[0-9abc]</code></td>
<td><code class="computeroutput"><span class="identifier">set</span><span class="special">[</span> <span class="identifier">range</span><span class="special">(</span><span class="char">'0'</span><span class="special">,</span><span class="char">'9'</span><span class="special">)</span> <span class="special">|</span> <span class="special">(</span><span class="identifier">set</span><span class="special">=</span> <span class="char">'a'</span><span class="special">,</span><span class="char">'b'</span><span class="special">,</span><span class="char">'c'</span><span class="special">)</span> <span class="special">]</span></code></td>
<td><span class="emphasis"><em>same
                as above</em></span></td>
</tr>
<tr>
<td><code class="literal">[^abc]</code></td>
<td><code class="computeroutput"><span class="special">~(</span><span class="identifier">set</span><span class="special">=</span> <span class="char">'a'</span><span class="special">,</span><span class="char">'b'</span><span class="special">,</span><span class="char">'c'</span><span class="special">)</span></code></td>
<td>not
                characters <code class="computeroutput"><span class="char">'a'</span></code>, <code class="computeroutput"><span class="char">'b'</span></code>, or <code class="computeroutput"><span class="char">'c'</span></code>.</td>
</tr>
<tr>
<td><code class="literal">(?i:<span class="emphasis"><em>stuff</em></span>)</code></td>
<td>
<code class="computeroutput"><span class="identifier">icase</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
</td>
<td>match <span class="emphasis"><em>stuff</em></span>
                disregarding case.</td>
</tr>
<tr>
<td><code class="literal">(?&gt;<span class="emphasis"><em>stuff</em></span>)</code></td>
<td>
<code class="computeroutput"><span class="identifier">keep</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
</td>
<td>independent sub-expression,
                match <span class="emphasis"><em>stuff</em></span> and turn off backtracking.</td>
</tr>
<tr>
<td><code class="literal">(?=<span class="emphasis"><em>stuff</em></span>)</code></td>
<td>
<code class="computeroutput"><span class="identifier">before</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
</td>
<td>positive look-ahead
                assertion, match if before <span class="emphasis"><em>stuff</em></span> but don't include
                <span class="emphasis"><em>stuff</em></span> in the match.</td>
</tr>
<tr>
<td><code class="literal">(?!<span class="emphasis"><em>stuff</em></span>)</code></td>
<td>
<code class="computeroutput"><span class="special">~</span><span class="identifier">before</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
</td>
<td>negative look-ahead
                assertion, match if not before <span class="emphasis"><em>stuff</em></span>.</td>
</tr>
<tr>
<td><code class="literal">(?&lt;=<span class="emphasis"><em>stuff</em></span>)</code></td>
<td>
<code class="computeroutput"><span class="identifier">after</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
</td>
<td>positive look-behind
                assertion, match if after <span class="emphasis"><em>stuff</em></span> but don't include
                <span class="emphasis"><em>stuff</em></span> in the match. (<span class="emphasis"><em>stuff</em></span>
                must be constant-width.)</td>
</tr>
<tr>
<td><code class="literal">(?&lt;!<span class="emphasis"><em>stuff</em></span>)</code></td>
<td>
<code class="computeroutput"><span class="special">~</span><span class="identifier">after</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>stuff</em></span></code><code class="computeroutput"><span class="special">)</span></code>
</td>
<td>negative look-behind
                assertion, match if not after <span class="emphasis"><em>stuff</em></span>. (<span class="emphasis"><em>stuff</em></span>
                must be constant-width.)</td>
</tr>
</tbody>
</table>
</div>
<p>
          <br>
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes"></a>Dynamic Regexes</h4></div></div></div>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes.overview"></a><h2>
<a name="id1977290"></a>
          Overview
        </h2>
<p>
          Static regexes are dandy, but sometimes you need something a bit more ...
          dynamic. Imagine you are developing a text editor with a regex search/replace
          feature. You need to accept a regular expression from the end user as input
          at run-time. There should be a way to parse a string into a regular expression.
          That's what xpressive's dynamic regexes are for. They are built from the
          same core components as their static counterparts, but they are late-bound
          so you can specify them at run-time.
        </p>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes.construction_and_assignment"></a><h2>
<a name="id1977309"></a>
          Construction and Assignment
        </h2>
<p>
          There are two ways to create a dynamic regex: with the <code class="literal"><code class="computeroutput">basic_regex::compile()</code></code>
          function or with the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
          class template. Use <code class="literal"><code class="computeroutput">basic_regex::compile()</code></code>
          if you want the default locale, syntax and semantics. Use <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
          if you need to specify a different locale, or if you need more control
          over the regex syntax and semantics than the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_constants/syntax_option_type.html" title="Type syntax_option_type">syntax_option_type</a></code></code>
          enumeration gives you. <span class="emphasis"><em>(Editor's note: in xpressive v1.0, <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
          does not support customization of the dynamic regex syntax and semantics.
          It will in v2.0.)</em></span>
        </p>
<p>
          Here is an example of using <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">&lt;&gt;::</span><span class="identifier">compile</span><span class="special">()</span></code>:
        </p>
<pre class="programlisting">
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"this|that"</span><span class="special">,</span> <span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">icase</span> <span class="special">);</span>
</pre>
<p>
          Here is the same example using <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>:
        </p>
<pre class="programlisting">
<span class="identifier">sregex_compiler</span> <span class="identifier">compiler</span><span class="special">;</span>
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">compiler</span><span class="special">.</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"this|that"</span><span class="special">,</span> <span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">icase</span> <span class="special">);</span>
</pre>
<p>
          <code class="literal"><code class="computeroutput">basic_regex::compile()</code></code>
          is implemented in terms of <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>.
        </p>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes.dynamic_xpressive_syntax"></a><h2>
<a name="id1977643"></a>
          Dynamic xpressive Syntax
        </h2>
<p>
          Since the dynamic syntax is not constrained by the rules for valid C++
          expressions, we are free to use familiar syntax for dynamic regexes. For
          this reason, the syntax used by xpressive for dynamic regexes follows the
          lead set by John Maddock's <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm" target="_top">proposal</a>
          to add regular expressions to the Standard Library. It is essentially the
          syntax standardized by <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" target="_top">ECMAScript</a>,
          with minor changes in support of internationalization.
        </p>
<p>
          Since the syntax is documented exhaustively elsewhere, I will simply refer
          you to the existing standards, rather than duplicate the specification
          here.
        </p>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes.customizing_dynamic_xpressive_syntax"></a><h2>
<a name="id1977690"></a>
          Customizing Dynamic xpressive Syntax
        </h2>
<p>
          xpressive v1.0 has limited support for the customization of dynamic regex
          syntax. The only customization allowed is what can be specified via the
          <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_constants/syntax_option_type.html" title="Type syntax_option_type">syntax_option_type</a></code></code>
          enumeration.
        </p>
<div class="informaltable"><table class="table">
<colgroup><col></colgroup>
<tbody><tr><td class="blurb"> I have planned some future work in this area
                for v2.0, however. xpressive's design allows for powerful mechanisms
                to customize the dynamic regex syntax. First, since the concept of
                "regex" is separated from the concept of "regex compiler",
                it will be possible to offer multiple regex compilers, each of which
                accepts a different syntax. Second, since xpressive allows you to
                build grammars using static regexes, it should be possible to build
                a dynamic regex parser out of static regexes! Then, new dynamic regex
                grammars can be created by cloning an existing regex grammar and
                modifying or disabling individual grammar rules to suit your needs.
                </td></tr></tbody>
</table></div>
<a name="boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes.internationalization"></a><h2>
<a name="id1977748"></a>
          Internationalization
        </h2>
<p>
          As with static regexes, dynamic regexes support internationalization by
          allowing you to specify a different <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>.
          To do this, you must use <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>.
          The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
          class has an <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>
          function. After you have imbued a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
          object with a custom <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>,
          all regex objects compiled by that <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>
          will use that locale. For example:
        </p>
<pre class="programlisting">
<span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span> <span class="identifier">my_locale</span> <span class="special">=</span> <span class="comment">/* initialize your locale object here */</span><span class="special">;</span>
<span class="identifier">sregex_compiler</span> <span class="identifier">compiler</span><span class="special">;</span>
<span class="identifier">compiler</span><span class="special">.</span><span class="identifier">imbue</span><span class="special">(</span> <span class="identifier">my_locale</span> <span class="special">);</span>
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">compiler</span><span class="special">.</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"\\w+|\\d+"</span> <span class="special">);</span>
</pre>
<p>
          This regex will use <code class="computeroutput"><span class="identifier">my_locale</span></code>
          when evaluating the intrinsic character sets <code class="computeroutput"><span class="string">"\\w"</span></code>
          and <code class="computeroutput"><span class="string">"\\d"</span></code>.
        </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.user_s_guide.matching_and_searching"></a>Matching and Searching</h3></div></div></div>
<a name="boost_xpressive.user_s_guide.matching_and_searching.overview"></a><h2>
<a name="id1978051"></a>
        Overview
      </h2>
<p>
        Once you have created a regex object, you can use the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
        and <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
        algorithms to find patterns in strings. This page covers the basics of regex
        matching and searching. In all cases, if you are familiar with how <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
        and <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
        in the <a href="../../../libs/regex" target="_top">Boost.Regex</a> library work, xpressive's
        versions work the same way.
      </p>
<a name="boost_xpressive.user_s_guide.matching_and_searching.seeing_if_a_string_matches_a_regex"></a><h2>
<a name="id1978137"></a>
        Seeing if a String Matches a Regex
      </h2>
<p>
        The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
        algorithm checks to see if a regex matches a given input.
      </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
          algorithm will only report success if the regex matches the <span class="emphasis"><em>whole
          input</em></span>, from beginning to end. If the regex matches only a part
          of the input, <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
          will return false. If you want to search through the string looking for
          sub-strings that the regex matches, use the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
          algorithm.
        </p></td></tr>
</table></div>
<p>
        The input can be a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>, a C-style null-terminated string
        or a pair of iterators. In all cases, the type of the iterator used to traverse
        the input sequence must match the iterator type used to declare the regex
        object. (You can use the table in the <a href="user_s_guide.html#boost_xpressive.user_s_guide.quick_start.know_your_iterator_type">Quick
        Start</a> to find the correct regex type for your iterator.)
      </p>
<pre class="programlisting">
<span class="identifier">cregex</span> <span class="identifier">cre</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">;</span>  <span class="comment">// this regex can match C-style strings
</span><span class="identifier">sregex</span> <span class="identifier">sre</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">;</span>  <span class="comment">// this regex can match std::strings
</span>
<span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="string">"hello"</span><span class="special">,</span> <span class="identifier">cre</span> <span class="special">)</span> <span class="special">)</span>              <span class="comment">// OK
</span>    <span class="special">{</span> <span class="comment">/*...*/</span> <span class="special">}</span>

<span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="string">"hello"</span><span class="special">),</span> <span class="identifier">sre</span> <span class="special">)</span> <span class="special">)</span> <span class="comment">// OK
</span>    <span class="special">{</span> <span class="comment">/*...*/</span> <span class="special">}</span> 

<span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="string">"hello"</span><span class="special">,</span> <span class="identifier">sre</span> <span class="special">)</span> <span class="special">)</span>              <span class="comment">// ERROR! iterator mis-match!
</span>    <span class="special">{</span> <span class="comment">/*...*/</span> <span class="special">}</span>
</pre>
<p>
        The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
        algorithm optionally accepts a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        struct as an out parameter. If given, the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
        algorithm fills in the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        struct with information about which parts of the regex matched which parts
        of the input.
      </p>
<pre class="programlisting">
<span class="identifier">cmatch</span> <span class="identifier">what</span><span class="special">;</span>
<span class="identifier">cregex</span> <span class="identifier">cre</span> <span class="special">=</span> <span class="special">+(</span><span class="identifier">s1</span><span class="special">=</span> <span class="identifier">_w</span><span class="special">);</span>

<span class="comment">// store the results of the regex_match in "what"
</span><span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="string">"hello"</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">cre</span> <span class="special">)</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// prints "o"
</span><span class="special">}</span>
</pre>
<p>
        The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
        algorithm also optionally accepts a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_constants/match_flag_type.html" title="Type match_flag_type">match_flag_type</a></code></code>
        bitmask. With <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_constants/match_flag_type.html" title="Type match_flag_type">match_flag_type</a></code></code>,
        you can control certain aspects of how the match is evaluated. See the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_constants/match_flag_type.html" title="Type match_flag_type">match_flag_type</a></code></code>
        reference for a complete list of the flags and their meanings.
      </p>
<pre class="programlisting">
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span><span class="string">"hello"</span><span class="special">);</span>
<span class="identifier">sregex</span> <span class="identifier">sre</span> <span class="special">=</span> <span class="identifier">bol</span> <span class="special">&gt;&gt;</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">;</span>

<span class="comment">// match_not_bol means that "bol" should not match at [begin,begin)
</span><span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">sre</span><span class="special">,</span> <span class="identifier">regex_constants</span><span class="special">::</span><span class="identifier">match_not_bol</span> <span class="special">)</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// should never get here!!!
</span><span class="special">}</span>
</pre>
<p>
        Click <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples.see_if_a_whole_string_matches_a_regex">here</a>
        to see a complete example program that shows how to use <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>.
        And check the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
        reference to see a complete list of the available overloads.
      </p>
<a name="boost_xpressive.user_s_guide.matching_and_searching.searching_for_matching_sub_strings"></a><h2>
<a name="id1979112"></a>
        Searching for Matching Sub-Strings
      </h2>
<p>
        Use <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
        when you want to know if an input sequence contains a sub-sequence that a
        regex matches. <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
        will try to match the regex at the beginning of the input sequence and scan
        forward in the sequence until it either finds a match or exhausts the sequence.
      </p>
<p>
        In all other regards, <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
        behaves like <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code> <span class="emphasis"><em>(see
        above)</em></span>. In particular, it can operate on <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>,
        C-style null-terminated strings or iterator ranges. The same care must be
        taken to ensure that the iterator type of your regex matches the iterator
        type of your input sequence. As with <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>,
        you can optionally provide a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        struct to receive the results of the search, and a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_constants/match_flag_type.html" title="Type match_flag_type">match_flag_type</a></code></code>
        bitmask to control how the match is evaluated.
      </p>
<p>
        Click <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples.see_if_a_string_contains_a_sub_string_that_matches_a_regex">here</a>
        to see a complete example program that shows how to use <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>.
        And check the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
        reference to see a complete list of the available overloads.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.user_s_guide.accessing_results"></a>Accessing Results</h3></div></div></div>
<a name="boost_xpressive.user_s_guide.accessing_results.overview"></a><h2>
<a name="id1979316"></a>
        Overview
      </h2>
<p>
        Sometimes, it is not enough to know simply whether a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
        or <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
        was successful or not. If you pass an object of type <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        to <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
        or <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>,
        then after the algorithm has completed successfully the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        will contain extra information about which parts of the regex matched which
        parts of the sequence. In Perl, these sub-sequences are called <span class="emphasis"><em>back-references</em></span>,
        and they are stored in the variables <code class="literal">$1</code>, <code class="literal">$2</code>,
        etc. In xpressive, they are objects of type <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>,
        and they are stored in the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        structure, which acts as a vector of <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
        objects.
      </p>
<a name="boost_xpressive.user_s_guide.accessing_results.match_results"></a><h2>
<a name="id1979481"></a>
        match_results
      </h2>
<p>
        So, you've passed a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object to a regex algorithm, and the algorithm has succeeded. Now you want
        to examine the results. Most of what you'll be doing with the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object is indexing into it to access its internally stored <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
        objects, but there are a few other things you can do with a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object besides.
      </p>
<p>
        The table below shows how to access the information stored in a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object named <code class="computeroutput"><span class="identifier">what</span></code>.
      </p>
<div class="informaltable">
<h4>
<a name="id1979584"></a>
          <span class="table-title">match_results&lt;&gt; Accessors</span>
        </h4>
<table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>Accessor</th>
<th>Effects</th>
</tr></thead>
<tbody>
<tr>
<td><code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span></code></td>
<td>Returns
              the number of sub-matches, which is always greater than zero after
              a successful match because the full match is stored in the zero-th
              sub-match.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">what</span><span class="special">[</span><span class="identifier">n</span><span class="special">]</span></code></td>
<td>Returns
              the <span class="emphasis"><em>n</em></span>-th sub-match.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">length</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span></code></td>
<td>Returns
              the length of the <span class="emphasis"><em>n</em></span>-th sub-match. Same as <code class="computeroutput"><span class="identifier">what</span><span class="special">[</span><span class="identifier">n</span><span class="special">].</span><span class="identifier">length</span><span class="special">()</span></code>.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">position</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span></code></td>
<td>Returns
              the offset into the input sequence at which the <span class="emphasis"><em>n</em></span>-th
              sub-match begins.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">str</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span></code></td>
<td>Returns
              a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>
              constructed from the <span class="emphasis"><em>n</em></span>-th sub-match. Same as
              <code class="computeroutput"><span class="identifier">what</span><span class="special">[</span><span class="identifier">n</span><span class="special">].</span><span class="identifier">str</span><span class="special">()</span></code>.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">prefix</span><span class="special">()</span></code></td>
<td>Returns
              a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
              object which represents the sub-sequence from the beginning of the
              input sequence to the start of the full match.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">suffix</span><span class="special">()</span></code></td>
<td>Returns
              a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
              object which represents the sub-sequence from the end of the full match
              to the end of the input sequence.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">what</span><span class="special">.</span><span class="identifier">regex_id</span><span class="special">()</span></code></td>
<td>Returns
              the <code class="computeroutput"><span class="identifier">regex_id</span></code> of the
              <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
              object that was last used with this <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
              object.</td>
</tr>
</tbody>
</table>
</div>
<p>
        There is more you can do with the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object, but that will be covered when we talk about <a href="user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches" title="Grammars and Nested Matches">Grammars
        and Nested Matches</a>.
      </p>
<a name="boost_xpressive.user_s_guide.accessing_results.sub_match"></a><h2>
<a name="id1980083"></a>
        sub_match
      </h2>
<p>
        When you index into a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object, you get back a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
        object. A <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
        is basically a pair of iterators. It is defined like this:
      </p>
<pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">BidirectionalIterator</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">sub_match</span>
    <span class="special">:</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span> <span class="identifier">BidirectionalIterator</span><span class="special">,</span> <span class="identifier">BidirectionalIterator</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">bool</span> <span class="identifier">matched</span><span class="special">;</span>
    <span class="comment">// ...
</span><span class="special">};</span>
</pre>
<p>
        Since it inherits publicaly from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;&gt;</span></code>, <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
        has <code class="computeroutput"><span class="identifier">first</span></code> and <code class="computeroutput"><span class="identifier">second</span></code> data members of type <code class="computeroutput"><span class="identifier">BidirectionalIterator</span></code>. These are the beginning
        and end of the sub-sequence this <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
        represents. <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
        also has a Boolean <code class="computeroutput"><span class="identifier">matched</span></code>
        data member, which is true if this <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
        participated in the full match.
      </p>
<p>
        The following table shows how you might access the information stored in
        a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/sub_match.html" title="Struct template sub_match">sub_match&lt;&gt;</a></code></code>
        object called <code class="computeroutput"><span class="identifier">sub</span></code>.
      </p>
<div class="informaltable">
<h4>
<a name="id1980410"></a>
          <span class="table-title">sub_match&lt;&gt; Accessors</span>
        </h4>
<table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>Accessor</th>
<th>Effects</th>
</tr></thead>
<tbody>
<tr>
<td><code class="computeroutput"><span class="identifier">sub</span><span class="special">.</span><span class="identifier">length</span><span class="special">()</span></code></td>
<td>Returns
              the length of the sub-match. Same as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">distance</span><span class="special">(</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">first</span><span class="special">,</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">second</span><span class="special">)</span></code>.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">sub</span><span class="special">.</span><span class="identifier">str</span><span class="special">()</span></code></td>
<td>Returns
              a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>
              constructed from the sub-match. Same as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">&gt;(</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">first</span><span class="special">,</span><span class="identifier">sub</span><span class="special">.</span><span class="identifier">second</span><span class="special">)</span></code>.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">sub</span><span class="special">.</span><span class="identifier">compare</span><span class="special">(</span><span class="identifier">str</span><span class="special">)</span></code></td>
<td>Performs
              a string comparison between the sub-match and <code class="computeroutput"><span class="identifier">str</span></code>,
              where <code class="computeroutput"><span class="identifier">str</span></code> can be a
              <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>,
              C-style null-terminated string, or another sub-match. Same as <code class="computeroutput"><span class="identifier">sub</span><span class="special">.</span><span class="identifier">str</span><span class="special">().</span><span class="identifier">compare</span><span class="special">(</span><span class="identifier">str</span><span class="special">)</span></code>.</td>
</tr>
</tbody>
</table>
</div>
<a name="boost_xpressive.user_s_guide.accessing_results._inlinemediaobject__imageobject__imagedata_fileref__images_caution_png____imagedata___imageobject__textobject__phrase_caution__phrase___textobject___inlinemediaobject__results_invalidation__inlinemediaobject__imageobject__imagedata_fileref__images_caution_png____imagedata___imageobject__textobject__phrase_caution__phrase___textobject___inlinemediaobject_"></a><h2>
<a name="id1980774"></a>
        <span class="inlinemediaobject"><img src="../images/caution.png" alt="caution"></span> Results Invalidation <span class="inlinemediaobject"><img src="../images/caution.png" alt="caution"></span>
      </h2>
<p>
        Results are stored as iterators into the input sequence. Anything which invalidates
        the input sequence will invalidate the match results. For instance, if you
        match a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> object, the results are only valid
        until your next call to a non-const member function of that <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
        object. After that, the results held by the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object are invalid. Don't use them!
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.user_s_guide.string_substitutions"></a>String Substitutions</h3></div></div></div>
<p>
        Regular expressions are not only good for searching text; they're good at
        <span class="emphasis"><em>manipulating</em></span> it. And one of the most common text manipulation
        tasks is search-and-replace. xpressive provides the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
        algorithm for searching and replacing.
      </p>
<a name="boost_xpressive.user_s_guide.string_substitutions.regex_replace__"></a><h2>
<a name="id1980923"></a>
        regex_replace()
      </h2>
<p>
        Performing search-and-replace using <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
        is simple. All you need is an input sequence, a regex object, and a format
        string. There are two versions of the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
        algorithm. The first accepts the input sequence as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code> and returns the result in a new
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>.
        The second accepts the input sequence as a pair of iterators, and writes
        the result into an output iterator. Below are examples of each.
      </p>
<pre class="programlisting">
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"This is his face"</span><span class="special">);</span>
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">as_xpr</span><span class="special">(</span><span class="string">"his"</span><span class="special">);</span>                <span class="comment">// find all occurrences of "his" ...
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">format</span><span class="special">(</span><span class="string">"her"</span><span class="special">);</span>                <span class="comment">// ... and replace them with "her"
</span>
<span class="comment">// use the version of regex_replace() that operates on strings
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">output</span> <span class="special">=</span> <span class="identifier">regex_replace</span><span class="special">(</span> <span class="identifier">input</span><span class="special">,</span> <span class="identifier">re</span><span class="special">,</span> <span class="identifier">format</span> <span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">output</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>

<span class="comment">// use the version of regex_replace() that operates on iterators
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span> <span class="keyword">char</span> <span class="special">&gt;</span> <span class="identifier">out_iter</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">);</span>
<span class="identifier">regex_replace</span><span class="special">(</span> <span class="identifier">out_iter</span><span class="special">,</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">re</span><span class="special">,</span> <span class="identifier">format</span> <span class="special">);</span>
</pre>
<p>
        The above program prints out the following:
      </p>
<pre class="programlisting">Ther is her face
Ther is her face
</pre>
<p>
        Notice that <span class="emphasis"><em>all</em></span> the occurrences of <code class="computeroutput"><span class="string">"his"</span></code>
        have been replaced with <code class="computeroutput"><span class="string">"her"</span></code>.
      </p>
<p>
        Click <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples.replace_all_sub_strings_that_match_a_regex">here</a>
        to see a complete example program that shows how to use <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>.
        And check the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
        reference to see a complete list of the available overloads.
      </p>
<a name="boost_xpressive.user_s_guide.string_substitutions.the_format_string"></a><h2>
<a name="id1981470"></a>
        The Format String
      </h2>
<p>
        As with Perl, you can refer to sub-matches in the format string. The table
        below shows the escape sequences xpressive recognizes in the format string.
      </p>
<div class="informaltable">
<h4>
<a name="id1981486"></a>
          <span class="table-title">Format Escape Sequences</span>
        </h4>
<table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>Escape Sequence</th>
<th>Meaning</th>
</tr></thead>
<tbody>
<tr>
<td><code class="literal">$1</code></td>
<td>the first sub-match</td>
</tr>
<tr>
<td><code class="literal">$2</code></td>
<td>the second sub-match (etc.)</td>
</tr>
<tr>
<td><code class="literal">$&amp;</code></td>
<td>the full match</td>
</tr>
<tr>
<td><code class="literal">$`</code></td>
<td>the match prefix</td>
</tr>
<tr>
<td><code class="literal">$'</code></td>
<td>the match suffix</td>
</tr>
<tr>
<td><code class="literal">$$</code></td>
<td>a literal <code class="computeroutput"><span class="char">'$'</span></code> character</td>
</tr>
</tbody>
</table>
</div>
<p>
        Any other sequence beginning with <code class="computeroutput"><span class="char">'$'</span></code>
        simply represents itself. For example, if the format string were <code class="computeroutput"><span class="string">"$a"</span></code> then <code class="computeroutput"><span class="string">"$a"</span></code>
        would be inserted into the output sequence.
      </p>
<a name="boost_xpressive.user_s_guide.string_substitutions.replace_options"></a><h2>
<a name="id1981642"></a>
        Replace Options
      </h2>
<p>
        The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_replace.html" title="Function regex_replace">regex_replace()</a></code></code>
        algorithm takes an optional bitmask parameter to control the formatting.
        The possible values of the bitmask are:
      </p>
<div class="informaltable">
<h4>
<a name="id1981670"></a>
          <span class="table-title">Format Flags</span>
        </h4>
<table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>Flag</th>
<th>Meaning</th>
</tr></thead>
<tbody>
<tr>
<td><code class="computeroutput"><span class="identifier">format_first_only</span></code></td>
<td>Only
              replace the first match, not all of them.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">format_no_copy</span></code></td>
<td>Don't
              copy the parts of the input sequence that didn't match the regex to
              the output sequence.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">format_literal</span></code></td>
<td>Treat
              the format string as a literal; that is, don't recognize any escape
              sequences.</td>
</tr>
</tbody>
</table>
</div>
<p>
        These flags live in the <code class="computeroutput"><span class="identifier">regex_constants</span></code>
        namespace.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.user_s_guide.string_splitting_and_tokenization"></a>String Splitting and Tokenization</h3></div></div></div>
<p>
        <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        is the Ginsu knife of the text manipulation world. It slices! It dices! This
        section describes how to use the highly-configurable <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        to chop up input sequences.
      </p>
<a name="boost_xpressive.user_s_guide.string_splitting_and_tokenization.overview"></a><h2>
<a name="id1981824"></a>
        Overview
      </h2>
<p>
        You initialize a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        with an input sequence, a regex, and some optional configuration parameters.
        The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        will use <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
        to find the first place in the sequence that the regex matches. When dereferenced,
        the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        returns a <span class="emphasis"><em>token</em></span> in the form of a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>. Which string it returns depends
        on the configuration parameters. By default it returns a string corresponding
        to the full match, but it could also return a string corresponding to a particular
        marked sub-expression, or even the part of the sequence that <span class="emphasis"><em>didn't</em></span>
        match. When you increment the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>,
        it will move to the next token. Which token is next depends on the configuration
        parameters. It could simply be a different marked sub-expression in the current
        match, or it could be part or all of the next match. Or it could be the part
        that <span class="emphasis"><em>didn't</em></span> match.
      </p>
<p>
        As you can see, <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        can do a lot. That makes it hard to describe, but some examples should make
        it clear.
      </p>
<a name="boost_xpressive.user_s_guide.string_splitting_and_tokenization.example_1__simple_tokenization"></a><h2>
<a name="id1981983"></a>
        Example 1: Simple Tokenization
      </h2>
<p>
        This example uses <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        to chop a sequence into a series of tokens consisting of words.
      </p>
<pre class="programlisting">
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"This is his face"</span><span class="special">);</span>
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_w</span><span class="special">;</span>                      <span class="comment">// find a word
</span>
<span class="comment">// iterate over all the words in the input
</span><span class="identifier">sregex_token_iterator</span> <span class="identifier">begin</span><span class="special">(</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">re</span> <span class="special">),</span> <span class="identifier">end</span><span class="special">;</span>

<span class="comment">// write all the words to std::cout
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">out_iter</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">"\n"</span> <span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">out_iter</span> <span class="special">);</span>
</pre>
<p>
        This program displays the following:
      </p>
<pre class="programlisting">This
is
his
face
</pre>
<a name="boost_xpressive.user_s_guide.string_splitting_and_tokenization.example_2__simple_tokenization__reloaded"></a><h2>
<a name="id1982313"></a>
        Example 2: Simple Tokenization, Reloaded
      </h2>
<p>
        This example also uses <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        to chop a sequence into a series of tokens consisting of words, but it uses
        the regex as a delimiter. When we pass a <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code> as the last parameter to the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        constructor, it instructs the token iterator to consider as tokens those
        parts of the input that <span class="emphasis"><em>didn't</em></span> match the regex.
      </p>
<pre class="programlisting">
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"This is his face"</span><span class="special">);</span>
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_s</span><span class="special">;</span>                      <span class="comment">// find white space
</span>
<span class="comment">// iterate over all non-white space in the input. Note the -1 below:
</span><span class="identifier">sregex_token_iterator</span> <span class="identifier">begin</span><span class="special">(</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">re</span><span class="special">,</span> <span class="special">-</span><span class="number">1</span> <span class="special">),</span> <span class="identifier">end</span><span class="special">;</span>

<span class="comment">// write all the words to std::cout
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">out_iter</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">"\n"</span> <span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">out_iter</span> <span class="special">);</span>
</pre>
<p>
        This program displays the following:
      </p>
<pre class="programlisting">This
is
his
face
</pre>
<a name="boost_xpressive.user_s_guide.string_splitting_and_tokenization.example_3__simple_tokenization__revolutions"></a><h2>
<a name="id1982692"></a>
        Example 3: Simple Tokenization, Revolutions
      </h2>
<p>
        This example also uses <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        to chop a sequence containing a bunch of dates into a series of tokens consisting
        of just the years. When we pass a positive integer <code class="literal"><span class="emphasis"><em>N</em></span></code>
        as the last parameter to the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        constructor, it instructs the token iterator to consider as tokens only the
        <code class="literal"><span class="emphasis"><em>N</em></span></code>-th marked sub-expression of each
        match.
      </p>
<pre class="programlisting">
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"01/02/2003 blahblah 04/23/1999 blahblah 11/13/1981"</span><span class="special">);</span>
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span><span class="string">"(\\d{2})/(\\d{2})/(\\d{4})"</span><span class="special">);</span> <span class="comment">// find a date
</span>
<span class="comment">// iterate over all the years in the input. Note the 3 below, corresponding to the 3rd sub-expression:
</span><span class="identifier">sregex_token_iterator</span> <span class="identifier">begin</span><span class="special">(</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">re</span><span class="special">,</span> <span class="number">3</span> <span class="special">),</span> <span class="identifier">end</span><span class="special">;</span>

<span class="comment">// write all the words to std::cout
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">out_iter</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">"\n"</span> <span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">out_iter</span> <span class="special">);</span>
</pre>
<p>
        This program displays the following:
      </p>
<pre class="programlisting">2003
1999
1981
</pre>
<a name="boost_xpressive.user_s_guide.string_splitting_and_tokenization.example_4__not_so_simple_tokenization"></a><h2>
<a name="id1983079"></a>
        Example 4: Not-So-Simple Tokenization
      </h2>
<p>
        This example is like the previous one, except that instead of tokenizing
        just the years, this program turns the days, months and years into tokens.
        When we pass an array of integers <code class="literal"><span class="emphasis"><em>{I,J,...}</em></span></code>
        as the last parameter to the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        constructor, it instructs the token iterator to consider as tokens the <code class="literal"><span class="emphasis"><em>I</em></span></code>-th,
        <code class="literal"><span class="emphasis"><em>J</em></span></code>-th, etc. marked sub-expression
        of each match.
      </p>
<pre class="programlisting">
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">(</span><span class="string">"01/02/2003 blahblah 04/23/1999 blahblah 11/13/1981"</span><span class="special">);</span>
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span><span class="string">"(\\d{2})/(\\d{2})/(\\d{4})"</span><span class="special">);</span> <span class="comment">// find a date
</span>
<span class="comment">// iterate over the days, months and years in the input
</span><span class="keyword">int</span> <span class="keyword">const</span> <span class="identifier">sub_matches</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">2</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="number">3</span> <span class="special">};</span> <span class="comment">// day, month, year
</span><span class="identifier">sregex_token_iterator</span> <span class="identifier">begin</span><span class="special">(</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">input</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">re</span><span class="special">,</span> <span class="identifier">sub_matches</span> <span class="special">),</span> <span class="identifier">end</span><span class="special">;</span>

<span class="comment">// write all the words to std::cout
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">out_iter</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">,</span> <span class="string">"\n"</span> <span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">out_iter</span> <span class="special">);</span>
</pre>
<p>
        This program displays the following:
      </p>
<pre class="programlisting">02
01
2003
23
04
1999
13
11
1981
</pre>
<p>
        The <code class="computeroutput"><span class="identifier">sub_matches</span></code> array instructs
        the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        to first take the value of the 2nd sub-match, then the 1st sub-match, and
        finally the 3rd. Incrementing the iterator again instructs it to use <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
        again to find the next match. At that point, the process repeats -- the token
        iterator takes the value of the 2nd sub-match, then the 1st, et cetera.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches"></a>Grammars and Nested Matches</h3></div></div></div>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.overview"></a><h2>
<a name="id1983581"></a>
        Overview
      </h2>
<p>
        One of the key benefits of representing regexes as C++ expressions is the
        ability to easily refer to other C++ code and data from within the regex.
        This enables programming idioms that are not possible with other regular
        expression libraries. Of particular note is the ability for one regex to
        refer to another regex, allowing you to build grammars out of regular expressions.
        This section describes how to embed one regex in another by value and by
        reference, how regex objects behave when they refer to other regexes, and
        how to access the tree of results after a successful parse.
      </p>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.embedding_a_regex_by_value"></a><h2>
<a name="id1983600"></a>
        Embedding a Regex by Value
      </h2>
<p>
        The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
        object has value semantics. When a regex object appears on the right-hand
        side in the definition of another regex, it is as if the regex were embedded
        by value; that is, a copy of the nested regex is stored by the enclosing
        regex. The inner regex is invoked by the outer regex during pattern matching.
        The inner regex participates fully in the match, back-tracking as needed
        to make the match succeed.
      </p>
<p>
        Consider a text editor that has a regex-find feature with a whole-word option.
        You can implement this with xpressive as follows:
      </p>
<pre class="programlisting">
<span class="identifier">find_dialog</span> <span class="identifier">dlg</span><span class="special">;</span>
<span class="keyword">if</span><span class="special">(</span> <span class="identifier">dialog_ok</span> <span class="special">==</span> <span class="identifier">dlg</span><span class="special">.</span><span class="identifier">do_modal</span><span class="special">()</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">pattern</span> <span class="special">=</span> <span class="identifier">dlg</span><span class="special">.</span><span class="identifier">get_text</span><span class="special">();</span>          <span class="comment">// the pattern the user entered
</span>    <span class="keyword">bool</span> <span class="identifier">whole_word</span> <span class="special">=</span> <span class="identifier">dlg</span><span class="special">.</span><span class="identifier">whole_word</span><span class="special">.</span><span class="identifier">is_checked</span><span class="special">();</span> <span class="comment">// did the user select the whole-word option?
</span>
    <span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="identifier">pattern</span> <span class="special">);</span>        <span class="comment">// try to compile the pattern
</span>
    <span class="keyword">if</span><span class="special">(</span> <span class="identifier">whole_word</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="comment">// wrap the regex in begin-word / end-word assertions
</span>        <span class="identifier">re</span> <span class="special">=</span> <span class="identifier">bow</span> <span class="special">&gt;&gt;</span> <span class="identifier">re</span> <span class="special">&gt;&gt;</span> <span class="identifier">eow</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// ... use re ...
</span><span class="special">}</span>
</pre>
<p>
        Look closely at this line:
      </p>
<pre class="programlisting">
<span class="comment">// wrap the regex in begin-word / end-word assertions
</span><span class="identifier">re</span> <span class="special">=</span> <span class="identifier">bow</span> <span class="special">&gt;&gt;</span> <span class="identifier">re</span> <span class="special">&gt;&gt;</span> <span class="identifier">eow</span><span class="special">;</span>
</pre>
<p>
        This line creates a new regex that embeds the old regex by value. Then, the
        new regex is assigned back to the original regex. Since a copy of the old
        regex was made on the right-hand side, this works as you might expect: the
        new regex has the behavior of the old regex wrapped in begin- and end-word
        assertions.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          Note that <code class="computeroutput"><span class="identifier">re</span> <span class="special">=</span> <span class="identifier">bow</span> <span class="special">&gt;&gt;</span> <span class="identifier">re</span> <span class="special">&gt;&gt;</span> <span class="identifier">eow</span></code> does <span class="emphasis"><em>not</em></span> define
          a recursive regular expression, since regex objects embed by value by default.
          The next section shows how to define a recursive regular expression by
          embedding a regex by reference.
        </p></td></tr>
</table></div>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.embedding_a_regex_by_reference"></a><h2>
<a name="id1984080"></a>
        Embedding a Regex by Reference
      </h2>
<p>
        If you want to be able to build recursive regular expressions and context-free
        grammars, embedding a regex by value is not enough. You need to be able to
        make your regular expressions self-referential. Most regular expression engines
        don't give you that power, but xpressive does.
      </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          The theoretical computer scientists out there will correctly point out
          that a self-referential regular expression is not "regular",
          so in the strict sense, xpressive isn't really a <span class="emphasis"><em>regular</em></span>
          expression engine at all. But as Larry Wall once said, "the term 
[regular expression]
          has grown with the capabilities of our pattern matching engines, so I'm
          not going to try to fight linguistic necessity here."
        </p></td></tr>
</table></div>
<p>
        Consider the following code, which uses the <code class="computeroutput"><span class="identifier">by_ref</span><span class="special">()</span></code> helper to define a recursive regular expression
        that matches balanced, nested parentheses:
      </p>
<pre class="programlisting">
<span class="identifier">sregex</span> <span class="identifier">parentheses</span><span class="special">;</span>
<span class="identifier">parentheses</span>                          <span class="comment">// A balanced set of parentheses ...
</span>    <span class="special">=</span> <span class="char">'('</span>                            <span class="comment">// is an opening parenthesis ...
</span>        <span class="special">&gt;&gt;</span>                           <span class="comment">// followed by ...
</span>         <span class="special">*(</span>                          <span class="comment">// zero or more ...
</span>            <span class="identifier">keep</span><span class="special">(</span> <span class="special">+~(</span><span class="identifier">set</span><span class="special">=</span><span class="char">'('</span><span class="special">,</span><span class="char">')'</span><span class="special">)</span> <span class="special">)</span>  <span class="comment">// of a bunch of things that are not parentheses ...
</span>          <span class="special">|</span>                          <span class="comment">// or ...
</span>            <span class="identifier">by_ref</span><span class="special">(</span><span class="identifier">parentheses</span><span class="special">)</span>      <span class="comment">// a balanced set of parentheses
</span>          <span class="special">)</span>                          <span class="comment">//   (ooh, recursion!) ...
</span>        <span class="special">&gt;&gt;</span>                           <span class="comment">// followed by ...
</span>      <span class="char">')'</span>                            <span class="comment">// a closing parenthesis
</span>    <span class="special">;</span>
</pre>
<p>
        Matching balanced, nested tags is an important text processing task, and
        it is one that "classic" regular expressions cannot do. The <code class="computeroutput"><span class="identifier">by_ref</span><span class="special">()</span></code>
        helper makes it possible. It allows one regex object to be embedded in another
        <span class="emphasis"><em>by reference</em></span>. Since the right-hand side holds <code class="computeroutput"><span class="identifier">parentheses</span></code> by reference, assigning the
        right-hand side back to <code class="computeroutput"><span class="identifier">parentheses</span></code>
        creates a cycle, which will execute recursively.
      </p>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.building_a_grammar"></a><h2>
<a name="id1984385"></a>
        Building a Grammar
      </h2>
<p>
        Once we allow self-reference in our regular expressions, the genie is out
        of the bottle and all manner of fun things are possible. In particular, we
        can now build grammars out of regular expressions. Let's have a look at the
        text-book grammar example: the humble calculator.
      </p>
<pre class="programlisting">
<span class="identifier">sregex</span> <span class="identifier">group</span><span class="special">,</span> <span class="identifier">factor</span><span class="special">,</span> <span class="identifier">term</span><span class="special">,</span> <span class="identifier">expression</span><span class="special">;</span>

<span class="identifier">group</span>       <span class="special">=</span> <span class="char">'('</span> <span class="special">&gt;&gt;</span> <span class="identifier">by_ref</span><span class="special">(</span><span class="identifier">expression</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span><span class="special">;</span>
<span class="identifier">factor</span>      <span class="special">=</span> <span class="special">+</span><span class="identifier">_d</span> <span class="special">|</span> <span class="identifier">group</span><span class="special">;</span>
<span class="identifier">term</span>        <span class="special">=</span> <span class="identifier">factor</span> <span class="special">&gt;&gt;</span> <span class="special">*((</span><span class="char">'*'</span> <span class="special">&gt;&gt;</span> <span class="identifier">factor</span><span class="special">)</span> <span class="special">|</span> <span class="special">(</span><span class="char">'/'</span> <span class="special">&gt;&gt;</span> <span class="identifier">factor</span><span class="special">));</span>
<span class="identifier">expression</span>  <span class="special">=</span> <span class="identifier">term</span> <span class="special">&gt;&gt;</span> <span class="special">*((</span><span class="char">'+'</span> <span class="special">&gt;&gt;</span> <span class="identifier">term</span><span class="special">)</span> <span class="special">|</span> <span class="special">(</span><span class="char">'-'</span> <span class="special">&gt;&gt;</span> <span class="identifier">term</span><span class="special">));</span>
</pre>
<p>
        The regex <code class="computeroutput"><span class="identifier">expression</span></code> defined
        above does something rather remarkable for a regular expression: it matches
        mathematical expressions. For example, if the input string were <code class="computeroutput"><span class="string">"foo 9*(10+3) bar"</span></code>, this pattern
        would match <code class="computeroutput"><span class="string">"9*(10+3)"</span></code>.
        It only matches well-formed mathematical expressions, where the parentheses
        are balanced and the infix operators have two arguments each. Don't try this
        with just any regular expression engine!
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          There is no way for a dynamic regex to refer to other regexes, so they
          can only be used as terminals in a grammar. Use static regexes for non-terminal
          grammar rules.
        </p></td></tr>
</table></div>
<p>
        Let's take a closer look at this regular expression grammar. Notice that
        it is cyclic: <code class="computeroutput"><span class="identifier">expression</span></code>
        is implemented in terms of <code class="computeroutput"><span class="identifier">term</span></code>,
        which is implemented in terms of <code class="computeroutput"><span class="identifier">factor</span></code>,
        which is implemented in terms of <code class="computeroutput"><span class="identifier">group</span></code>,
        which is implemented in terms of <code class="computeroutput"><span class="identifier">expression</span></code>,
        closing the loop. In general, the way to define a cyclic grammar is to forward-declare
        the regex objects and embed by reference those regular expressions that have
        not yet been initialized. In the above grammar, there is only one place where
        we need to reference a regex object that has not yet been initialized: the
        definition of <code class="computeroutput"><span class="identifier">group</span></code>. In that
        place, we use <code class="computeroutput"><span class="identifier">by_ref</span><span class="special">()</span></code>
        to embed <code class="computeroutput"><span class="identifier">expression</span></code> by reference.
        In all other places, it is sufficient to embed the other regex objects by
        value, since they have already been initialized and their values will not
        change.
      </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          <span class="bold"><strong>Embed by value if possible</strong></span> <br> <br>
          In general, prefer embedding regular expressions by value rather than by
          reference. It involves one less indirection, making your patterns match
          a little faster. Besides, value semantics are simpler and will make your
          grammars easier to reason about. Don't worry about the expense of "copying"
          a regex. Each regex object shares its implementation with all of its copies.
        </p></td></tr>
</table></div>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.cyclic_patterns__copying_and_memory_management__oh_my_"></a><h2>
<a name="id1984872"></a>
        Cyclic Patterns, Copying and Memory Management, Oh My!
      </h2>
<p>
        The calculator example above raises a number of very complicated memory-management
        issues. Each of the four regex objects refer to each other, some directly
        and some indirectly, some by value and some by reference. What if we were
        to return one of them from a function and let the others go out of scope?
        What becomes of the references? The answer is that the regex objects are
        internally reference counted, such that they keep their referenced regex
        objects alive as long as they need them. So passing a regex object by value
        is never a problem, even if it refers to other regex objects that have gone
        out of scope.
      </p>
<p>
        Those of you who have dealt with reference counting are probably familiar
        with its Achilles Heel: cyclic references. If regex objects are reference
        counted, what happens to cycles like the one created in the calculator example?
        Are they leaked? The answer is no, they are not leaked. The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
        object has some tricky reference tracking code that ensures that even cyclic
        regex grammars are cleaned up when the last external reference goes away.
        So don't worry about it. Create cyclic grammars, pass your regex objects
        around and copy them all you want. It is fast and efficient and guaranteed
        not to leak or result in dangling references.
      </p>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.nested_regexes_and_sub_match_scoping"></a><h2>
<a name="id1984919"></a>
        Nested Regexes and Sub-Match Scoping
      </h2>
<p>
        Nested regular expressions raise the issue of sub-match scoping. If both
        the inner and outer regex write to and read from the same sub-match vector,
        chaos would ensue. The inner regex would stomp on the sub-matches written
        by the outer regex. For example, what does this do?
      </p>
<pre class="programlisting">
<span class="identifier">sregex</span> <span class="identifier">inner</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"(.)\\1"</span> <span class="special">);</span>
<span class="identifier">sregex</span> <span class="identifier">outer</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">s1</span><span class="special">=</span> <span class="identifier">_</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="identifier">inner</span> <span class="special">&gt;&gt;</span> <span class="identifier">s1</span><span class="special">;</span>
</pre>
<p>
        The author probably didn't intend for the inner regex to overwrite the sub-match
        written by the outer regex. The problem is particularly acute when the inner
        regex is accepted from the user as input. The author has no way of knowing
        whether the inner regex will stomp the sub-match vector or not. This is clearly
        not acceptable.
      </p>
<p>
        Instead, what actually happens is that each invocation of a nested regex
        gets its own scope. Sub-matches belong to that scope. That is, each nested
        regex invocation gets its own copy of the sub-match vector to play with,
        so there is no way for an inner regex to stomp on the sub-matches of an outer
        regex. So, for example, the regex <code class="computeroutput"><span class="identifier">outer</span></code>
        defined above would match <code class="computeroutput"><span class="string">"ABBA"</span></code>,
        as it should.
      </p>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.nested_results"></a><h2>
<a name="id1985098"></a>
        Nested Results
      </h2>
<p>
        If nested regexes have their own sub-matches, there should be a way to access
        them after a successful match. In fact, there is. After a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
        or <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>,
        the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        struct behaves like the head of a tree of nested results. The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        class provides a <code class="computeroutput"><span class="identifier">nested_results</span><span class="special">()</span></code> member function that returns an ordered
        sequence of <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        structures, representing the results of the nested regexes. The order of
        the nested results is the same as the order in which the nested regex objects
        matched.
      </p>
<p>
        Take as an example the regex for balanced, nested parentheses we saw earlier:
      </p>
<pre class="programlisting">
<span class="identifier">sregex</span> <span class="identifier">parentheses</span><span class="special">;</span>
<span class="identifier">parentheses</span> <span class="special">=</span> <span class="char">'('</span> <span class="special">&gt;&gt;</span> <span class="special">*(</span> <span class="identifier">keep</span><span class="special">(</span> <span class="special">+~(</span><span class="identifier">set</span><span class="special">=</span><span class="char">'('</span><span class="special">,</span><span class="char">')'</span><span class="special">)</span> <span class="special">)</span> <span class="special">|</span> <span class="identifier">by_ref</span><span class="special">(</span><span class="identifier">parentheses</span><span class="special">)</span> <span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span><span class="special">;</span>

<span class="identifier">smatch</span> <span class="identifier">what</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span> <span class="string">"blah blah( a(b)c (c(e)f (g)h )i (j)6 )blah"</span> <span class="special">);</span>

<span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_search</span><span class="special">(</span> <span class="identifier">str</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">parentheses</span> <span class="special">)</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// display the whole match
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>

    <span class="comment">// display the nested results
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span>
        <span class="identifier">what</span><span class="special">.</span><span class="identifier">nested_results</span><span class="special">().</span><span class="identifier">begin</span><span class="special">(),</span>
        <span class="identifier">what</span><span class="special">.</span><span class="identifier">nested_results</span><span class="special">().</span><span class="identifier">end</span><span class="special">(),</span>
        <span class="identifier">output_nested_results</span><span class="special">()</span> <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        This program displays the following:
      </p>
<pre class="programlisting">( a(b)c (c(e)f (g)h )i (j)6 )
    (b)
    (c(e)f (g)h )
        (e)
        (g)
    (j)
</pre>
<p>
        Here you can see how the results are nested and that they are stored in the
        order in which they are found.
      </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          See the definition of <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples.display_a_tree_of_nested_results">output_nested_results</a>
          in the <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">Examples</a>
          section.
        </p></td></tr>
</table></div>
<a name="boost_xpressive.user_s_guide.grammars_and_nested_matches.filtering_nested_results"></a><h2>
<a name="id1985664"></a>
        Filtering Nested Results
      </h2>
<p>
        Sometimes a regex will have several nested regex objects, and you want to
        know which result corresponds to which regex object. That's where <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">&lt;&gt;::</span><span class="identifier">regex_id</span><span class="special">()</span></code>
        and <code class="computeroutput"><span class="identifier">match_results</span><span class="special">&lt;&gt;::</span><span class="identifier">regex_id</span><span class="special">()</span></code>
        come in handy. When iterating over the nested results, you can compare the
        regex id from the results to the id of the regex object you're interested
        in.
      </p>
<p>
        To make this a bit easier, xpressive provides a predicate to make it simple
        to iterate over just the results that correspond to a certain nested regex.
        It is called <code class="computeroutput"><span class="identifier">regex_id_filter_predicate</span></code>,
        and it is intended to be used with <a href="../../../libs/iterator/doc/index.html" target="_top">Boost.Iterator</a>.
        You can use it as follows:
      </p>
<pre class="programlisting">
<span class="identifier">sregex</span> <span class="identifier">name</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">alpha</span><span class="special">;</span>
<span class="identifier">sregex</span> <span class="identifier">integer</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">_d</span><span class="special">;</span>
<span class="identifier">sregex</span> <span class="identifier">re</span> <span class="special">=</span> <span class="special">*(</span> <span class="special">*</span><span class="identifier">_s</span> <span class="special">&gt;&gt;</span> <span class="special">(</span> <span class="identifier">name</span> <span class="special">|</span> <span class="identifier">integer</span> <span class="special">)</span> <span class="special">);</span> 

<span class="identifier">smatch</span> <span class="identifier">what</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span> <span class="string">"marsha 123 jan 456 cindy 789"</span> <span class="special">);</span>

<span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="identifier">str</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">re</span> <span class="special">)</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">smatch</span><span class="special">::</span><span class="identifier">nested_results_type</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">begin</span> <span class="special">=</span> <span class="identifier">what</span><span class="special">.</span><span class="identifier">nested_results</span><span class="special">().</span><span class="identifier">begin</span><span class="special">();</span>
    <span class="identifier">smatch</span><span class="special">::</span><span class="identifier">nested_results_type</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">end</span>   <span class="special">=</span> <span class="identifier">what</span><span class="special">.</span><span class="identifier">nested_results</span><span class="special">().</span><span class="identifier">end</span><span class="special">();</span>

    <span class="comment">// declare filter predicates to select just the names or the integers
</span>    <span class="identifier">sregex_id_filter_predicate</span> <span class="identifier">name_id</span><span class="special">(</span> <span class="identifier">name</span><span class="special">.</span><span class="identifier">regex_id</span><span class="special">()</span> <span class="special">);</span>
    <span class="identifier">sregex_id_filter_predicate</span> <span class="identifier">integer_id</span><span class="special">(</span> <span class="identifier">integer</span><span class="special">.</span><span class="identifier">regex_id</span><span class="special">()</span> <span class="special">);</span>

    <span class="comment">// iterate over only the results from the name regex
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_filter_iterator</span><span class="special">(</span> <span class="identifier">name_id</span><span class="special">,</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span> <span class="special">),</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_filter_iterator</span><span class="special">(</span> <span class="identifier">name_id</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">end</span> <span class="special">),</span>
        <span class="identifier">output_result</span>
        <span class="special">);</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>

    <span class="comment">// iterate over only the results from the integer regex
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_filter_iterator</span><span class="special">(</span> <span class="identifier">integer_id</span><span class="special">,</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span> <span class="special">),</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_filter_iterator</span><span class="special">(</span> <span class="identifier">integer_id</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">end</span> <span class="special">),</span>
        <span class="identifier">output_result</span>
        <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        where <code class="computeroutput"><span class="identifier">output_results</span></code> is a
        simple function that takes a <code class="computeroutput"><span class="identifier">smatch</span></code>
        and displays the full match. Notice how we use the <code class="computeroutput"><span class="identifier">regex_id_filter_predicate</span></code>
        together with <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">&lt;&gt;::</span><span class="identifier">regex_id</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_filter_iterator</span><span class="special">()</span></code> from the <a href="../../../libs/iterator/doc/index.html" target="_top">Boost.Iterator</a>
        to select only those results corresponding to a particular nested regex.
        This program displays the following:
      </p>
<pre class="programlisting">marsha
jan
cindy
123
456
789
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.user_s_guide.localization_and_regex_traits"></a>Localization and Regex Traits</h3></div></div></div>
<a name="boost_xpressive.user_s_guide.localization_and_regex_traits.overview"></a><h2>
<a name="id1986618"></a>
        Overview
      </h2>
<p>
        Matching a regular expression against a string often requires locale-dependent
        information. For example, how are case-insensitive comparisons performed?
        The locale-sensitive behavior is captured in a traits class. xpressive provides
        three traits class templates: <code class="computeroutput"><span class="identifier">cpp_regex_traits</span><span class="special">&lt;&gt;</span></code>, <code class="computeroutput"><span class="identifier">c_regex_traits</span><span class="special">&lt;&gt;</span></code> and <code class="computeroutput"><span class="identifier">null_regex_traits</span><span class="special">&lt;&gt;</span></code>. The first wraps a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>,
        the second wraps the global C locale, and the third is a stub traits type
        for use when searching non-character data. All traits templates conform to
        the <a href="user_s_guide.html#boost_xpressive.user_s_guide.concepts.traits_requirements">Regex
        Traits Concept</a>.
      </p>
<a name="boost_xpressive.user_s_guide.localization_and_regex_traits.setting_the_default_regex_trait"></a><h2>
<a name="id1986712"></a>
        Setting the Default Regex Trait
      </h2>
<p>
        By default, xpressive uses <code class="computeroutput"><span class="identifier">cpp_regex_traits</span><span class="special">&lt;&gt;</span></code> for all patterns. This causes all
        regex objects to use the global <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>.
        If you compile with <code class="computeroutput"><span class="identifier">BOOST_XPRESSIVE_USE_C_TRAITS</span></code>
        defined, then xpressive will use <code class="computeroutput"><span class="identifier">c_regex_traits</span><span class="special">&lt;&gt;</span></code> by default.
      </p>
<a name="boost_xpressive.user_s_guide.localization_and_regex_traits.using_custom_traits_with_dynamic_regexes"></a><h2>
<a name="id1986789"></a>
        Using Custom Traits with Dynamic Regexes
      </h2>
<p>
        To create a dynamic regex that uses a custom traits object, you must use
        <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_compiler.html" title="Struct template regex_compiler">regex_compiler&lt;&gt;</a></code></code>.
        The basic steps are shown in the following example:
      </p>
<pre class="programlisting">
<span class="comment">// Declare a regex_compiler that uses the global C locale
</span><span class="identifier">regex_compiler</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*,</span> <span class="identifier">c_regex_traits</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">crxcomp</span><span class="special">;</span>
<span class="identifier">cregex</span> <span class="identifier">crx</span> <span class="special">=</span> <span class="identifier">crxcomp</span><span class="special">.</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"\\w+"</span> <span class="special">);</span>

<span class="comment">// Declare a regex_compiler that uses a custom std::locale
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span> <span class="identifier">loc</span> <span class="special">=</span> <span class="comment">/* ... create a locale here ... */</span><span class="special">;</span>
<span class="identifier">regex_compiler</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*,</span> <span class="identifier">cpp_regex_traits</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">cpprxcomp</span><span class="special">(</span><span class="identifier">loc</span><span class="special">);</span>
<span class="identifier">cregex</span> <span class="identifier">cpprx</span> <span class="special">=</span> <span class="identifier">cpprxcomp</span><span class="special">.</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"\\w+"</span> <span class="special">);</span>
</pre>
<p>
        The <code class="computeroutput"><span class="identifier">regex_compiler</span></code> objects
        act as regex factories. Once they have been imbued with a locale, every regex
        object they create will use that locale.
      </p>
<a name="boost_xpressive.user_s_guide.localization_and_regex_traits.using_custom_traits_with_static_regexes"></a><h2>
<a name="id1987111"></a>
        Using Custom Traits with Static Regexes
      </h2>
<p>
        If you want a particular static regex to use a different set of traits, you
        can use the special <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code> pattern modifier. For instance:
      </p>
<pre class="programlisting">
<span class="comment">// Define a regex that uses the global C locale
</span><span class="identifier">c_regex_traits</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="identifier">ctraits</span><span class="special">;</span>
<span class="identifier">sregex</span> <span class="identifier">crx</span> <span class="special">=</span> <span class="identifier">imbue</span><span class="special">(</span><span class="identifier">ctraits</span><span class="special">)(</span> <span class="special">+</span><span class="identifier">_w</span> <span class="special">);</span>

<span class="comment">// Define a regex that uses a customized std::locale
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span> <span class="identifier">loc</span> <span class="special">=</span> <span class="comment">/* ... create a locale here ... */</span><span class="special">;</span>
<span class="identifier">cpp_regex_traits</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="identifier">cpptraits</span><span class="special">(</span><span class="identifier">loc</span><span class="special">);</span>
<span class="identifier">sregex</span> <span class="identifier">cpprx1</span> <span class="special">=</span> <span class="identifier">imbue</span><span class="special">(</span><span class="identifier">cpptraits</span><span class="special">)(</span> <span class="special">+</span><span class="identifier">_w</span> <span class="special">);</span>

<span class="comment">// A sharthand for above
</span><span class="identifier">sregex</span> <span class="identifier">cpprx2</span> <span class="special">=</span> <span class="identifier">imbue</span><span class="special">(</span><span class="identifier">loc</span><span class="special">)(</span> <span class="special">+</span><span class="identifier">_w</span> <span class="special">);</span>
</pre>
<p>
        The <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>
        pattern modifier must wrap the entire pattern. It is an error to <code class="computeroutput"><span class="identifier">imbue</span></code> only part of a static regex. For
        example:
      </p>
<pre class="programlisting">
<span class="comment">// ERROR! Cannot imbue() only part of a regex
</span><span class="identifier">sregex</span> <span class="identifier">error</span> <span class="special">=</span> <span class="identifier">_w</span> <span class="special">&gt;&gt;</span> <span class="identifier">imbue</span><span class="special">(</span><span class="identifier">loc</span><span class="special">)(</span> <span class="identifier">_w</span> <span class="special">);</span>
</pre>
<a name="boost_xpressive.user_s_guide.localization_and_regex_traits.searching_non_character_data_with__literal_null_regex_traits__literal_"></a><h2>
<a name="id1987516"></a>
        Searching Non-Character Data With <code class="literal">null_regex_traits</code>
      </h2>
<p>
        With xpressive static regexes, you are not limitted to searching for patterns
        in character sequences. You can search for patterns in raw bytes, integers,
        or anything that conforms to the <a href="user_s_guide.html#boost_xpressive.user_s_guide.concepts.chart_requirements">Char
        Concept</a>. The <code class="computeroutput"><span class="identifier">null_regex_traits</span><span class="special">&lt;&gt;</span></code> makes it simple. It is a stub implementation
        of the <a href="user_s_guide.html#boost_xpressive.user_s_guide.concepts.traits_requirements">Regex
        Traits Concept</a>. It recognizes no character classes and does no case-sensitive
        mappings.
      </p>
<p>
        For example, with <code class="computeroutput"><span class="identifier">null_regex_traits</span><span class="special">&lt;&gt;</span></code>, you can write a static regex to
        find a pattern in a sequence of integers as follows:
      </p>
<pre class="programlisting">
<span class="comment">// some integral data to search
</span><span class="keyword">int</span> <span class="keyword">const</span> <span class="identifier">data</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span><span class="number">0</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="number">2</span><span class="special">,</span> <span class="number">3</span><span class="special">,</span> <span class="number">4</span><span class="special">,</span> <span class="number">5</span><span class="special">,</span> <span class="number">6</span><span class="special">};</span>

<span class="comment">// create a null_regex_traits&lt;&gt; object for searching integers ...
</span><span class="identifier">null_regex_traits</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">nul</span><span class="special">;</span>

<span class="comment">// imbue a regex object with the null_regex_traits ...
</span><span class="identifier">basic_regex</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="keyword">const</span> <span class="special">*&gt;</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="identifier">imbue</span><span class="special">(</span><span class="identifier">nul</span><span class="special">)(</span><span class="number">1</span> <span class="special">&gt;&gt;</span> <span class="special">+((</span><span class="identifier">set</span><span class="special">=</span> <span class="number">2</span><span class="special">,</span><span class="number">3</span><span class="special">)</span> <span class="special">|</span> <span class="number">4</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="number">5</span><span class="special">);</span>
<span class="identifier">match_results</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="keyword">const</span> <span class="special">*&gt;</span> <span class="identifier">what</span><span class="special">;</span>

<span class="comment">// search for the pattern in the array of integers ...
</span><span class="identifier">regex_search</span><span class="special">(</span><span class="identifier">data</span><span class="special">,</span> <span class="identifier">data</span> <span class="special">+</span> <span class="number">7</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">rex</span><span class="special">);</span>

<span class="identifier">assert</span><span class="special">(</span><span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">].</span><span class="identifier">matched</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(*</span><span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">].</span><span class="identifier">first</span> <span class="special">==</span> <span class="number">1</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(*</span><span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">].</span><span class="identifier">second</span> <span class="special">==</span> <span class="number">6</span><span class="special">);</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.user_s_guide.tips_n_tricks"></a> Tips 'N Tricks</h3></div></div></div>
<p>
        Squeeze the most performance out of xpressive with these tips and tricks.
      </p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.use_static_regexes"></a><h2>
<a name="id1988115"></a>
        Use Static Regexes
      </h2>
<p>
        On average, static regexes execute about 10 to 15% faster than their dynamic
        counterparts. It's worth familiarizing yourself with the static regex dialect.
      </p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.reuse__literal__classname_alt__boost__xpressive__match_results__match_results_lt__gt___classname___literal__objects"></a><h2>
<a name="id1988141"></a>
        Reuse <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        Objects
      </h2>
<p>
        The <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object caches dynamically allocated memory. For this reason, it is far better
        to reuse the same <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object if you have to do many regex searches.
      </p>
<p>
        Caveat: <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        objects are not thread-safe, so don't go wild reusing them across threads.
      </p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.prefer_algorithms_that_take_a__literal__classname_alt__boost__xpressive__match_results__match_results_lt__gt___classname___literal__object"></a><h2>
<a name="id1988226"></a>
        Prefer Algorithms That Take A <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        Object
      </h2>
<p>
        This is a corollary to the previous tip. If you are doing multiple searches,
        you should prefer the regex algorithms that accept a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object over the ones that don't, and you should reuse the same <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object each time. If you don't provide a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>
        object, a temporary one will be created for you and discarded when the algorithm
        returns. Any memory cached in the object will be deallocated and will have
        to be reallocated the next time.
      </p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.prefer_algorithms_that_accept_iterator_ranges_over_null_terminated_strings"></a><h2>
<a name="id1988309"></a>
        Prefer Algorithms That Accept Iterator Ranges Over Null-Terminated Strings
      </h2>
<p>
        xpressive provides overloads of the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_match.html" title="Function regex_match">regex_match()</a></code></code>
        and <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_search.html" title="Function regex_search">regex_search()</a></code></code>
        algorithms that operate on C-style null-terminated strings. You should prefer
        the overloads that take iterator ranges. When you pass a null-terminated
        string to a regex algorithm, the end iterator is calculated immediately by
        calling <code class="computeroutput"><span class="identifier">strlen</span></code>. If you already
        know the length of the string, you can avoid this overhead by calling the
        regex algorithms with a <code class="computeroutput"><span class="special">[</span><span class="identifier">begin</span><span class="special">,</span> <span class="identifier">end</span><span class="special">)</span></code> pair.
      </p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.compile_patterns_once_and_reuse_them"></a><h2>
<a name="id1988398"></a>
        Compile Patterns Once And Reuse Them
      </h2>
<p>
        Compiling a regex (dynamic or static) is more expensive than executing a
        match or search. If you have the option, prefer to compile a pattern into
        a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>
        object once and reuse it rather than recreating it over and over.
      </p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.understand__literal_syntax_option_type__optimize__literal_"></a><h2>
<a name="id1988436"></a>
        Understand <code class="literal">syntax_option_type::optimize</code>
      </h2>
<p>
        The <code class="computeroutput"><span class="identifier">optimize</span></code> flag tells the
        regex compiler to spend some extra time analyzing the pattern. It can cause
        some patterns to execute faster, but it increases the time to compile the
        pattern, and often increases the amount of memory consumed by the pattern.
        If you plan to reuse your pattern, <code class="computeroutput"><span class="identifier">optimize</span></code>
        is usually a win. If you will only use the pattern once, don't use <code class="computeroutput"><span class="identifier">optimize</span></code>.
      </p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.common_pitfalls"></a><h1>
<a name="id1988430"></a>
        Common Pitfalls
      </h1>
<p>
        Keep the following tips in mind to avoid stepping in potholes with xpressive.
      </p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.create_grammars_on_a_single_thread"></a><h2>
<a name="id1988509"></a>
        Create Grammars On A Single Thread
      </h2>
<p>
        With static regexes, you can create grammars by nesting regexes inside one
        another. When compiling the outer regex, both the outer and inner regex objects,
        and all the regex objects to which they refer either directly or indirectly,
        are modified. For this reason, it's dangerous for global regex objects to
        participate in grammars. It's best to build regex grammars from a single
        thread. Once built, the resulting regex grammar can be executed from multiple
        threads without problems.
      </p>
<a name="boost_xpressive.user_s_guide.tips_n_tricks.beware_nested_quantifiers"></a><h2>
<a name="id1988527"></a>
        Beware Nested Quantifiers
      </h2>
<p>
        This is a pitfall common to many regular expression engines. Some patterns
        can cause exponentially bad performance. Often these patterns involve one
        quantified term nested withing another quantifier, such as <code class="computeroutput"><span class="string">"(a*)*"</span></code>, although in many cases,
        the problem is harder to spot. Beware of patterns that have nested quantifiers.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.user_s_guide.concepts"></a>Concepts</h3></div></div></div>
<a name="boost_xpressive.user_s_guide.concepts.chart_requirements"></a><h2>
<a name="id1988568"></a>
        CharT requirements
      </h2>
<p>
        If type <code class="computeroutput"><span class="identifier">BidiIterT</span></code> is used
        as a template argument to <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>,
        then <code class="computeroutput"><span class="identifier">CharT</span></code> is <code class="computeroutput"><span class="identifier">iterator_traits</span><span class="special">&lt;</span><span class="identifier">BidiIterT</span><span class="special">&gt;::</span><span class="identifier">value_type</span></code>. Type <code class="computeroutput"><span class="identifier">CharT</span></code>
        must have a trivial default constructor, copy constructor, assignment operator,
        and destructor. In addition the following requirements must be met for objects;
        <code class="computeroutput"><span class="identifier">c</span></code> of type <code class="computeroutput"><span class="identifier">CharT</span></code>,
        <code class="computeroutput"><span class="identifier">c1</span></code> and <code class="computeroutput"><span class="identifier">c2</span></code>
        of type <code class="computeroutput"><span class="identifier">CharT</span> <span class="keyword">const</span></code>,
        and <code class="computeroutput"><span class="identifier">i</span></code> of type <code class="computeroutput"><span class="keyword">int</span></code>:
      </p>
<div class="informaltable">
<h4>
<a name="id1988722"></a>
          <span class="table-title">CharT Requirements</span>
        </h4>
<table class="table">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th><span class="bold"><strong>Expression</strong></span></th>
<th><span class="bold"><strong>Return type</strong></span></th>
<th><span class="bold"><strong>Assertion
              / Note / Pre- / Post-condition</strong></span></th>
</tr></thead>
<tbody>
<tr>
<td><code class="computeroutput"><span class="identifier">CharT</span> <span class="identifier">c</span></code></td>
<td><code class="computeroutput"><span class="identifier">CharT</span></code></td>
<td>Default
              constructor (must be trivial).</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">CharT</span> <span class="identifier">c</span><span class="special">(</span><span class="identifier">c1</span><span class="special">)</span></code></td>
<td><code class="computeroutput"><span class="identifier">CharT</span></code></td>
<td>Copy constructor
              (must be trivial).</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">c1</span> <span class="special">=</span> <span class="identifier">c2</span></code></td>
<td><code class="computeroutput"><span class="identifier">CharT</span></code></td>
<td>Assignment
              operator (must be trivial).</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">c1</span> <span class="special">==</span> <span class="identifier">c2</span></code></td>
<td><code class="computeroutput"><span class="keyword">bool</span></code></td>
<td>
<code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="identifier">c1</span></code>
              has the same value as <code class="computeroutput"><span class="identifier">c2</span></code>.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">c1</span> <span class="special">!=</span> <span class="identifier">c2</span></code></td>
<td><code class="computeroutput"><span class="keyword">bool</span></code></td>
<td>
<code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="identifier">c1</span></code>
              and <code class="computeroutput"><span class="identifier">c2</span></code> are not equal.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">c1</span> <span class="special">&lt;</span> <span class="identifier">c2</span></code></td>
<td><code class="computeroutput"><span class="keyword">bool</span></code></td>
<td>
<code class="computeroutput"><span class="keyword">true</span></code> if the value of <code class="computeroutput"><span class="identifier">c1</span></code>
              is less than <code class="computeroutput"><span class="identifier">c2</span></code>.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">c1</span> <span class="special">&gt;</span> <span class="identifier">c2</span></code></td>
<td><code class="computeroutput"><span class="keyword">bool</span></code></td>
<td>
<code class="computeroutput"><span class="keyword">true</span></code> if the value of <code class="computeroutput"><span class="identifier">c1</span></code>
              is greater than <code class="computeroutput"><span class="identifier">c2</span></code>.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">c1</span> <span class="special">&lt;=</span> <span class="identifier">c2</span></code></td>
<td><code class="computeroutput"><span class="keyword">bool</span></code></td>
<td>
<code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="identifier">c1</span></code>
              is less than or equal to <code class="computeroutput"><span class="identifier">c2</span></code>.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">c1</span> <span class="special">&gt;=</span> <span class="identifier">c2</span></code></td>
<td><code class="computeroutput"><span class="keyword">bool</span></code></td>
<td>
<code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="identifier">c1</span></code>
              is greater than or equal to <code class="computeroutput"><span class="identifier">c2</span></code>.</td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">intmax_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">c1</span></code></td>
<td><code class="computeroutput"><span class="keyword">int</span></code></td>
<td>
              <code class="computeroutput"><span class="identifier">CharT</span></code> must be convertible
              to an integral type. </td>
</tr>
<tr>
<td><code class="computeroutput"><span class="identifier">CharT</span> <span class="identifier">c</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span></code></td>
<td><code class="computeroutput"><span class="identifier">CharT</span></code></td>
<td>
<code class="computeroutput"><span class="identifier">CharT</span></code> must be constructable from
              an integral type.</td>
</tr>
</tbody>
</table>
</div>
<a name="boost_xpressive.user_s_guide.concepts.traits_requirements"></a><h2>
<a name="id1989353"></a>
        Traits Requirements
      </h2>
<p>
        In the following table <code class="computeroutput"><span class="identifier">X</span></code>
        denotes a traits class defining types and functions for the character container
        type <code class="computeroutput"><span class="identifier">CharT</span></code>; <code class="computeroutput"><span class="identifier">u</span></code> is an object of type <code class="computeroutput"><span class="identifier">X</span></code>;
        <code class="computeroutput"><span class="identifier">v</span></code> is an object of type <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">X</span></code>;
        <code class="computeroutput"><span class="identifier">p</span></code> is a value of type <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">CharT</span><span class="special">*</span></code>; <code class="computeroutput"><span class="identifier">I1</span></code>
        and <code class="computeroutput"><span class="identifier">I2</span></code> are <code class="computeroutput"><span class="identifier">Input</span> <span class="identifier">Iterators</span></code>;
        <code class="computeroutput"><span class="identifier">c</span></code> is a value of type <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">CharT</span></code>;
        <code class="computeroutput"><span class="identifier">s</span></code> is an object of type <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code>;
        <code class="computeroutput"><span class="identifier">cs</span></code> is an object of type
        <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code>;
        <code class="computeroutput"><span class="identifier">b</span></code> is a value of type <code class="computeroutput"><span class="keyword">bool</span></code>; <code class="computeroutput"><span class="identifier">i</span></code>
        is a value of type <code class="computeroutput"><span class="keyword">int</span></code>; <code class="computeroutput"><span class="identifier">F1</span></code> and <code class="computeroutput"><span class="identifier">F2</span></code>
        are values of type <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">CharT</span><span class="special">*</span></code>;
        <code class="computeroutput"><span class="identifier">loc</span></code> is an object of type
        <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">locale_type</span></code>; and <code class="computeroutput"><span class="identifier">ch</span></code>
        is an object of <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">char</span></code>.
      </p>
<div class="informaltable">
<h4>
<a name="id1989695"></a>
          <span class="table-title">Traits Requirements</span>
        </h4>
<table class="table">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th> <span class="bold"><strong>Expression</strong></span> </th>
<th>
              <span class="bold"><strong>Return type</strong></span> </th>
<th> <span class="bold"><strong>Assertion / Note<br> Pre / Post condition</strong></span>
              </th>
</tr></thead>
<tbody>
<tr>
<td> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">char_type</span></code> </td>
<td> <code class="computeroutput"><span class="identifier">CharT</span></code> </td>
<td> The character
              container type used in the implementation of class template <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/basic_regex.html" title="Struct template basic_regex">basic_regex&lt;&gt;</a></code></code>.
              </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code> </td>
<td> <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special">&gt;</span></code>
              or <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special">&gt;</span></code>
              </td>
<td> </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">locale_type</span></code> </td>
<td> <span class="emphasis"><em>Implementation
              defined</em></span> </td>
<td> A copy constructible type that represents
              the locale used by the traits class. </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">char_class_type</span></code> </td>
<td>
              <span class="emphasis"><em>Implementation defined</em></span> </td>
<td> A bitmask
              type representing a particular character classification. Multiple values
              of this type can be bitwise-or'ed together to obtain a new valid value.
              </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">hash</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code>
              </td>
<td> <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">char</span></code> </td>
<td> Yields a value
              between <code class="computeroutput"><span class="number">0</span></code> and <code class="computeroutput"><span class="identifier">UCHAR_MAX</span></code> inclusive. </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">widen</span><span class="special">(</span><span class="identifier">ch</span><span class="special">)</span></code>
              </td>
<td> <code class="computeroutput"><span class="identifier">CharT</span></code>
              </td>
<td> Widens the specified <code class="computeroutput"><span class="keyword">char</span></code>
              and returns the resulting <code class="computeroutput"><span class="identifier">CharT</span></code>.
              </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">in_range</span><span class="special">(</span><span class="identifier">r1</span><span class="special">,</span> <span class="identifier">r2</span><span class="special">,</span> <span class="identifier">c</span><span class="special">)</span></code>
              </td>
<td> <code class="computeroutput"><span class="keyword">bool</span></code>
              </td>
<td> For any characters <code class="computeroutput"><span class="identifier">r1</span></code>
              and <code class="computeroutput"><span class="identifier">r2</span></code>, returns <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="identifier">r1</span> <span class="special">&lt;=</span> <span class="identifier">c</span> <span class="special">&amp;&amp;</span> <span class="identifier">c</span> <span class="special">&lt;=</span> <span class="identifier">r2</span></code>.
              Requires that <code class="computeroutput"><span class="identifier">r1</span> <span class="special">&lt;=</span> <span class="identifier">r2</span></code>.
              </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">in_range_nocase</span><span class="special">(</span><span class="identifier">r1</span><span class="special">,</span> <span class="identifier">r2</span><span class="special">,</span> <span class="identifier">c</span><span class="special">)</span></code>
              </td>
<td> <code class="computeroutput"><span class="keyword">bool</span></code>
              </td>
<td> For characters <code class="computeroutput"><span class="identifier">r1</span></code>
              and <code class="computeroutput"><span class="identifier">r2</span></code>, returns <code class="computeroutput"><span class="keyword">true</span></code> if there is some character <code class="computeroutput"><span class="identifier">d</span></code> for which <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">d</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code>
              and <code class="computeroutput"><span class="identifier">r1</span> <span class="special">&lt;=</span> <span class="identifier">d</span> <span class="special">&amp;&amp;</span> <span class="identifier">d</span> <span class="special">&lt;=</span> <span class="identifier">r2</span></code>. Requires that <code class="computeroutput"><span class="identifier">r1</span> <span class="special">&lt;=</span> <span class="identifier">r2</span></code>.
              </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">translate</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code>
              </td>
<td> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">char_type</span></code> </td>
<td> Returns
              a character such that for any character <code class="computeroutput"><span class="identifier">d</span></code>
              that is to be considered equivalent to <code class="computeroutput"><span class="identifier">c</span></code>
              then <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">translate</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">v</span><span class="special">.</span><span class="identifier">translate</span><span class="special">(</span><span class="identifier">d</span><span class="special">)</span></code>. </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code>
              </td>
<td> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">char_type</span></code> </td>
<td> For all
              characters <code class="computeroutput"><span class="identifier">C</span></code> that are
              to be considered equivalent to <code class="computeroutput"><span class="identifier">c</span></code>
              when comparisons are to be performed without regard to case, then
              <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">c</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">v</span><span class="special">.</span><span class="identifier">translate_nocase</span><span class="special">(</span><span class="identifier">C</span><span class="special">)</span></code>. </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code>
              </td>
<td> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code> </td>
<td> Returns
              a sort key for the character sequence designated by the iterator range
              <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code> such that if the character sequence
              <code class="computeroutput"><span class="special">[</span><span class="identifier">G1</span><span class="special">,</span> <span class="identifier">G2</span><span class="special">)</span></code> sorts before the character sequence
              <code class="computeroutput"><span class="special">[</span><span class="identifier">H1</span><span class="special">,</span> <span class="identifier">H2</span><span class="special">)</span></code> then <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">G1</span><span class="special">,</span> <span class="identifier">G2</span><span class="special">)</span> <span class="special">&lt;</span> <span class="identifier">v</span><span class="special">.</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">H1</span><span class="special">,</span> <span class="identifier">H2</span><span class="special">)</span></code>.
              </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">transform_primary</span><span class="special">(</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code>
              </td>
<td> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code> </td>
<td> Returns
              a sort key for the character sequence designated by the iterator range
              <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code> such that if the character sequence
              <code class="computeroutput"><span class="special">[</span><span class="identifier">G1</span><span class="special">,</span> <span class="identifier">G2</span><span class="special">)</span></code> sorts before the character sequence
              <code class="computeroutput"><span class="special">[</span><span class="identifier">H1</span><span class="special">,</span> <span class="identifier">H2</span><span class="special">)</span></code> when character case is not considered
              then <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">transform_primary</span><span class="special">(</span><span class="identifier">G1</span><span class="special">,</span> <span class="identifier">G2</span><span class="special">)</span> <span class="special">&lt;</span> <span class="identifier">v</span><span class="special">.</span><span class="identifier">transform_primary</span><span class="special">(</span><span class="identifier">H1</span><span class="special">,</span> <span class="identifier">H2</span><span class="special">)</span></code>. </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">lookup_classname</span><span class="special">(</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code>
              </td>
<td> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">char_class_type</span></code> </td>
<td> Converts
              the character sequence designated by the iterator range <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">)</span></code> into a bitmask type that can subsequently
              be passed to <code class="computeroutput"><span class="identifier">isctype</span></code>.
              Values returned from <code class="computeroutput"><span class="identifier">lookup_classname</span></code>
              can be safely bitwise or'ed together. Returns <code class="computeroutput"><span class="number">0</span></code>
              if the character sequence is not the name of a character class recognized
              by <code class="computeroutput"><span class="identifier">X</span></code>. The value returned
              shall be independent of the case of the characters in the sequence.
              </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">lookup_collatename</span><span class="special">(</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code>
              </td>
<td> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">string_type</span></code> </td>
<td> Returns
              a sequence of characters that represents the collating element consisting
              of the character sequence designated by the iterator range <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code>. Returns an empty string if the character
              sequence is not a valid collating element. </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">isctype</span><span class="special">(</span><span class="identifier">c</span><span class="special">,</span> <span class="identifier">v</span><span class="special">.</span><span class="identifier">lookup_classname</span><span class="special">(</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">))</span></code>
              </td>
<td> <code class="computeroutput"><span class="keyword">bool</span></code>
              </td>
<td> Returns <code class="computeroutput"><span class="keyword">true</span></code>
              if character <code class="computeroutput"><span class="identifier">c</span></code> is a
              member of the character class designated by the iterator range <code class="computeroutput"><span class="special">[</span><span class="identifier">F1</span><span class="special">,</span> <span class="identifier">F2</span><span class="special">)</span></code>, <code class="computeroutput"><span class="keyword">false</span></code>
              otherwise. </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">value</span><span class="special">(</span><span class="identifier">c</span><span class="special">,</span> <span class="identifier">i</span><span class="special">)</span></code>
              </td>
<td> <code class="computeroutput"><span class="keyword">int</span></code> </td>
<td>
              Returns the value represented by the digit <code class="computeroutput"><span class="identifier">c</span></code>
              in base <code class="computeroutput"><span class="identifier">i</span></code> if the character
              <code class="computeroutput"><span class="identifier">c</span></code> is a valid digit
              in base <code class="computeroutput"><span class="identifier">i</span></code>; otherwise
              returns <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>.<br>
              [Note: the value of <code class="computeroutput"><span class="identifier">i</span></code>
              will only be <code class="computeroutput"><span class="number">8</span></code>, <code class="computeroutput"><span class="number">10</span></code>, or <code class="computeroutput"><span class="number">16</span></code>.
              -end note] </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">u</span><span class="special">.</span><span class="identifier">imbue</span><span class="special">(</span><span class="identifier">loc</span><span class="special">)</span></code>
              </td>
<td> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">locale_type</span></code> </td>
<td> Imbues
              <code class="computeroutput"><span class="identifier">u</span></code> with the locale
              <code class="computeroutput"><span class="identifier">loc</span></code>, returns the previous
              locale used by <code class="computeroutput"><span class="identifier">u</span></code>.
              </td>
</tr>
<tr>
<td> <code class="computeroutput"><span class="identifier">v</span><span class="special">.</span><span class="identifier">getloc</span><span class="special">()</span></code>
              </td>
<td> <code class="computeroutput"><span class="identifier">X</span><span class="special">::</span><span class="identifier">locale_type</span></code> </td>
<td> Returns
              the current locale used by <code class="computeroutput"><span class="identifier">v</span></code>.
              </td>
</tr>
</tbody>
</table>
</div>
<a name="boost_xpressive.user_s_guide.concepts.acknowledgements"></a><h2>
<a name="id1991940"></a>
        Acknowledgements
      </h2>
<p>
        This section is adapted from the equivalent page in the <a href="../../../libs/regex" target="_top">Boost.Regex</a>
        documentation and from the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm" target="_top">proposal</a>
        to add regular expressions to the Standard Library.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.user_s_guide.examples"></a>Examples</h3></div></div></div>
<p>
        Below you can find six complete sample programs. <br>
      </p>
<p></p>
<a name="boost_xpressive.user_s_guide.examples.see_if_a_whole_string_matches_a_regex"></a><h4>
<a name="id1991994"></a>
        See if a whole string matches a regex
      </h4>
<p>
        This is the example from the Introduction. It is reproduced here for your
        convenience.
      </p>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">hello</span><span class="special">(</span> <span class="string">"hello world!"</span> <span class="special">);</span>

    <span class="identifier">sregex</span> <span class="identifier">rex</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"(\\w+) (\\w+)!"</span> <span class="special">);</span>
    <span class="identifier">smatch</span> <span class="identifier">what</span><span class="special">;</span>

    <span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_match</span><span class="special">(</span> <span class="identifier">hello</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">rex</span> <span class="special">)</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// whole match
</span>        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// first capture
</span>        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">2</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// second capture
</span>    <span class="special">}</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        This program outputs the following:
      </p>
<pre class="programlisting">hello world!
hello
world
</pre>
<p>
        <br> <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top</a>
      </p>
<p></p>
<a name="boost_xpressive.user_s_guide.examples.see_if_a_string_contains_a_sub_string_that_matches_a_regex"></a><h4>
<a name="id2010000"></a>
        See if a string contains a sub-string that matches a regex
      </h4>
<p>
        Notice in this example how we use custom <code class="computeroutput"><span class="identifier">mark_tag</span></code>s
        to make the pattern more readable. We can use the <code class="computeroutput"><span class="identifier">mark_tag</span></code>s
        later to index into the <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/match_results.html" title="Struct template match_results">match_results&lt;&gt;</a></code></code>.
      </p>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*</span><span class="identifier">str</span> <span class="special">=</span> <span class="string">"I was born on 5/30/1973 at 7am."</span><span class="special">;</span>

    <span class="comment">// define some custom mark_tags with names more meaningful than s1, s2, etc.
</span>    <span class="identifier">mark_tag</span> <span class="identifier">day</span><span class="special">(</span><span class="number">1</span><span class="special">),</span> <span class="identifier">month</span><span class="special">(</span><span class="number">2</span><span class="special">),</span> <span class="identifier">year</span><span class="special">(</span><span class="number">3</span><span class="special">),</span> <span class="identifier">delim</span><span class="special">(</span><span class="number">4</span><span class="special">);</span>

    <span class="comment">// this regex finds a date
</span>    <span class="identifier">cregex</span> <span class="identifier">date</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">month</span><span class="special">=</span> <span class="identifier">repeat</span><span class="special">&lt;</span><span class="number">1</span><span class="special">,</span><span class="number">2</span><span class="special">&gt;(</span><span class="identifier">_d</span><span class="special">))</span>           <span class="comment">// find the month ...
</span>               <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">delim</span><span class="special">=</span> <span class="special">(</span><span class="identifier">set</span><span class="special">=</span> <span class="char">'/'</span><span class="special">,</span><span class="char">'-'</span><span class="special">))</span>            <span class="comment">// followed by a delimiter ...
</span>               <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">day</span><span class="special">=</span>   <span class="identifier">repeat</span><span class="special">&lt;</span><span class="number">1</span><span class="special">,</span><span class="number">2</span><span class="special">&gt;(</span><span class="identifier">_d</span><span class="special">))</span> <span class="special">&gt;&gt;</span> <span class="identifier">delim</span>  <span class="comment">// and a day followed by the same delimiter ...
</span>               <span class="special">&gt;&gt;</span> <span class="special">(</span><span class="identifier">year</span><span class="special">=</span>  <span class="identifier">repeat</span><span class="special">&lt;</span><span class="number">1</span><span class="special">,</span><span class="number">2</span><span class="special">&gt;(</span><span class="identifier">_d</span> <span class="special">&gt;&gt;</span> <span class="identifier">_d</span><span class="special">));</span>    <span class="comment">// and the year.
</span>
    <span class="identifier">cmatch</span> <span class="identifier">what</span><span class="special">;</span>

    <span class="keyword">if</span><span class="special">(</span> <span class="identifier">regex_search</span><span class="special">(</span> <span class="identifier">str</span><span class="special">,</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">date</span> <span class="special">)</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span>     <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// whole match
</span>        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="identifier">day</span><span class="special">]</span>   <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// the day
</span>        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="identifier">month</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// the month
</span>        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="identifier">year</span><span class="special">]</span>  <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// the year
</span>        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="identifier">delim</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span> <span class="comment">// the delimiter
</span>    <span class="special">}</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        This program outputs the following:
      </p>
<pre class="programlisting">5/30/1973
30
5
1973
/
</pre>
<p>
        <br> <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top</a>
      </p>
<p></p>
<a name="boost_xpressive.user_s_guide.examples.replace_all_sub_strings_that_match_a_regex"></a><h4>
<a name="id2011002"></a>
        Replace all sub-strings that match a regex
      </h4>
<p>
        The following program finds dates in a string and marks them up with pseudo-HTML.
      </p>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span> <span class="string">"I was born on 5/30/1973 at 7am."</span> <span class="special">);</span>

    <span class="comment">// essentially the same regex as in the previous example, but using a dynamic regex
</span>    <span class="identifier">sregex</span> <span class="identifier">date</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"(\\d{1,2})([/-])(\\d{1,2})\\2((?:\\d{2}){1,2})"</span> <span class="special">);</span>

    <span class="comment">// As in Perl, $&amp; is a reference to the sub-string that matched the regex
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">format</span><span class="special">(</span> <span class="string">"&lt;date&gt;$&amp;&lt;/date&gt;"</span> <span class="special">);</span>

    <span class="identifier">str</span> <span class="special">=</span> <span class="identifier">regex_replace</span><span class="special">(</span> <span class="identifier">str</span><span class="special">,</span> <span class="identifier">date</span><span class="special">,</span> <span class="identifier">format</span> <span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        This program outputs the following:
      </p>
<pre class="programlisting">I was born on &lt;date&gt;5/30/1973&lt;/date&gt; at 7am.
</pre>
<p>
        <br> <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top</a>
      </p>
<p></p>
<a name="boost_xpressive.user_s_guide.examples.find_all_the_sub_strings_that_match_a_regex_and_step_through_them_one_at_a_time"></a><h4>
<a name="id2011417"></a>
        Find all the sub-strings that match a regex and step through them one at
        a time
      </h4>
<p>
        The following program finds the words in a wide-character string. It uses
        <code class="computeroutput"><span class="identifier">wsregex_iterator</span></code>. Notice
        that dereferencing a <code class="computeroutput"><span class="identifier">wsregex_iterator</span></code>
        yields a <code class="computeroutput"><span class="identifier">wsmatch</span></code> object.
      </p>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">wstring</span> <span class="identifier">str</span><span class="special">(</span> <span class="identifier">L</span><span class="string">"This is his face."</span> <span class="special">);</span>

    <span class="comment">// find a whole word
</span>    <span class="identifier">wsregex</span> <span class="identifier">token</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">alnum</span><span class="special">;</span>

    <span class="identifier">wsregex_iterator</span> <span class="identifier">cur</span><span class="special">(</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">token</span> <span class="special">);</span>
    <span class="identifier">wsregex_iterator</span> <span class="identifier">end</span><span class="special">;</span>

    <span class="keyword">for</span><span class="special">(</span> <span class="special">;</span> <span class="identifier">cur</span> <span class="special">!=</span> <span class="identifier">end</span><span class="special">;</span> <span class="special">++</span><span class="identifier">cur</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">wsmatch</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">what</span> <span class="special">=</span> <span class="special">*</span><span class="identifier">cur</span><span class="special">;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">wcout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="identifier">L</span><span class="char">'\n'</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        This program outputs the following:
      </p>
<pre class="programlisting">This
is
his
face
</pre>
<p>
        <br> <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top</a>
      </p>
<p></p>
<a name="boost_xpressive.user_s_guide.examples.split_a_string_into_tokens_that_each_match_a_regex"></a><h4>
<a name="id2011946"></a>
        Split a string into tokens that each match a regex
      </h4>
<p>
        The following program finds race times in a string and displays first the
        minutes and then the seconds. It uses <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>.
      </p>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span> <span class="string">"Eric: 4:40, Karl: 3:35, Francesca: 2:32"</span> <span class="special">);</span>

    <span class="comment">// find a race time
</span>    <span class="identifier">sregex</span> <span class="identifier">time</span> <span class="special">=</span> <span class="identifier">sregex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">(</span> <span class="string">"(\\d):(\\d\\d)"</span> <span class="special">);</span>

    <span class="comment">// for each match, the token iterator should first take the value of
</span>    <span class="comment">// the first marked sub-expression followed by the value of the second
</span>    <span class="comment">// marked sub-expression
</span>    <span class="keyword">int</span> <span class="keyword">const</span> <span class="identifier">subs</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span> <span class="number">1</span><span class="special">,</span> <span class="number">2</span> <span class="special">};</span>

    <span class="identifier">sregex_token_iterator</span> <span class="identifier">cur</span><span class="special">(</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">time</span><span class="special">,</span> <span class="identifier">subs</span> <span class="special">);</span>
    <span class="identifier">sregex_token_iterator</span> <span class="identifier">end</span><span class="special">;</span>

    <span class="keyword">for</span><span class="special">(</span> <span class="special">;</span> <span class="identifier">cur</span> <span class="special">!=</span> <span class="identifier">end</span><span class="special">;</span> <span class="special">++</span><span class="identifier">cur</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="identifier">cur</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        This program outputs the following:
      </p>
<pre class="programlisting">4
40
3
35
2
32
</pre>
<p>
        <br> <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top</a>
      </p>
<p></p>
<a name="boost_xpressive.user_s_guide.examples.split_a_string_using_a_regex_as_a_delimiter"></a><h4>
<a name="id2012502"></a>
        Split a string using a regex as a delimiter
      </h4>
<p>
        The following program takes some text that has been marked up with html and
        strips out the mark-up. It uses a regex that matches an HTML tag and a <code class="literal"><code class="computeroutput"><a href="../boost/xpressive/regex_token_iterator.html" title="Struct template regex_token_iterator">regex_token_iterator&lt;&gt;</a></code></code>
        that returns the parts of the string that do <span class="emphasis"><em>not</em></span> match
        the regex.
      </p>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">/</span><span class="identifier">xpressive</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">xpressive</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span> <span class="string">"Now &lt;bold&gt;is the time &lt;i&gt;for all good men&lt;/i&gt; to come to the aid of their&lt;/bold&gt; country."</span> <span class="special">);</span>

    <span class="comment">// find a HTML tag
</span>    <span class="identifier">sregex</span> <span class="identifier">html</span> <span class="special">=</span> <span class="char">'&lt;'</span> <span class="special">&gt;&gt;</span> <span class="identifier">optional</span><span class="special">(</span><span class="char">'/'</span><span class="special">)</span> <span class="special">&gt;&gt;</span> <span class="special">+</span><span class="identifier">_w</span> <span class="special">&gt;&gt;</span> <span class="char">'&gt;'</span><span class="special">;</span>

    <span class="comment">// the -1 below directs the token iterator to display the parts of
</span>    <span class="comment">// the string that did NOT match the regular expression.
</span>    <span class="identifier">sregex_token_iterator</span> <span class="identifier">cur</span><span class="special">(</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">html</span><span class="special">,</span> <span class="special">-</span><span class="number">1</span> <span class="special">);</span>
    <span class="identifier">sregex_token_iterator</span> <span class="identifier">end</span><span class="special">;</span>

    <span class="keyword">for</span><span class="special">(</span> <span class="special">;</span> <span class="identifier">cur</span> <span class="special">!=</span> <span class="identifier">end</span><span class="special">;</span> <span class="special">++</span><span class="identifier">cur</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'{'</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="identifier">cur</span> <span class="special">&lt;&lt;</span> <span class="char">'}'</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        This program outputs the following:
      </p>
<pre class="programlisting">{Now }{is the time }{for all good men}{ to come to the aid of their}{ country.}
</pre>
<p>
        <br> <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top</a>
      </p>
<p></p>
<a name="boost_xpressive.user_s_guide.examples.display_a_tree_of_nested_results"></a><h4>
<a name="id2013082"></a>
        Display a tree of nested results
      </h4>
<p>
        Here is a helper class to demonstrate how you might display a tree of nested
        results:
      </p>
<pre class="programlisting">
<span class="comment">// Displays nested results to std::cout with indenting
</span><span class="keyword">struct</span> <span class="identifier">output_nested_results</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">tabs_</span><span class="special">;</span>

    <span class="identifier">output_nested_results</span><span class="special">(</span> <span class="keyword">int</span> <span class="identifier">tabs</span> <span class="special">=</span> <span class="number">0</span> <span class="special">)</span>
        <span class="special">:</span> <span class="identifier">tabs_</span><span class="special">(</span> <span class="identifier">tabs</span> <span class="special">)</span>
    <span class="special">{</span>
    <span class="special">}</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">BidiIterT</span> <span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="special">()(</span> <span class="identifier">match_results</span><span class="special">&lt;</span> <span class="identifier">BidiIterT</span> <span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">what</span> <span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="comment">// first, do some indenting
</span>        <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">iterator_traits</span><span class="special">&lt;</span> <span class="identifier">BidiIterT</span> <span class="special">&gt;::</span><span class="identifier">value_type</span> <span class="identifier">char_type</span><span class="special">;</span>
        <span class="identifier">char_type</span> <span class="identifier">space_ch</span> <span class="special">=</span> <span class="identifier">char_type</span><span class="special">(</span><span class="char">' '</span><span class="special">);</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">fill_n</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream_iterator</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">&gt;(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">),</span> <span class="identifier">tabs_</span> <span class="special">*</span> <span class="number">4</span><span class="special">,</span> <span class="identifier">space_ch</span> <span class="special">);</span>

        <span class="comment">// output the match
</span>        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">what</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>

        <span class="comment">// output any nested matches
</span>        <span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span>
            <span class="identifier">what</span><span class="special">.</span><span class="identifier">nested_results</span><span class="special">().</span><span class="identifier">begin</span><span class="special">(),</span>
            <span class="identifier">what</span><span class="special">.</span><span class="identifier">nested_results</span><span class="special">().</span><span class="identifier">end</span><span class="special">(),</span>
            <span class="identifier">output_nested_results</span><span class="special">(</span> <span class="identifier">tabs_</span> <span class="special">+</span> <span class="number">1</span> <span class="special">)</span> <span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        <a href="user_s_guide.html#boost_xpressive.user_s_guide.examples" title="Examples">top</a>
      </p>
</div>
</div>
<table width="100%"><tr>
<td align="left"></td>
<td align="right"><small>Copyright © 2003, 2004 Eric Niebler</small></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../xpressive.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../xpressive.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="reference.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
