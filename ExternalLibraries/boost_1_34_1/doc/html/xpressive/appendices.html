<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Appendices</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.68.1">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../xpressive.html" title="Chapter 21. Boost.Xpressive">
<link rel="prev" href="../boost_xpressive/acknowledgments.html" title="Acknowledgments">
<link rel="next" href="../tools.html" title="Part II. Boost Tools">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%">
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.htm">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="../../../people/people.htm">People</a></td>
<td align="center"><a href="../../../more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../boost_xpressive/acknowledgments.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../xpressive.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="../tools.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="xpressive.appendices"></a>Appendices</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="appendices.html#boost_xpressive.appendices.appendix_1__not_yet_implemented">Appendix 1: Not Yet Implemented</a></span></dt>
<dt><span class="section"><a href="appendices.html#boost_xpressive.appendices.appendix_2__differences_from_boost_regex">Appendix 2: Differences from Boost.Regex</a></span></dt>
<dt><span class="section"><a href="appendices.html#boost_xpressive.appendices.perf"> Appendix 3: Performance Comparison</a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.appendices.appendix_1__not_yet_implemented"></a>Appendix 1: Not Yet Implemented</h3></div></div></div>
<p>
        The following features of xpressive have not yet been implemented, but are
        planned for the near future:<br> <br>
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          match_flag_type::format_sed
        </li>
<li>
          match_flag_type::format_perl <br>
</li>
</ul></div>
<p>
        The following features are planned for xpressive 2.0:<br> <br>
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          syntax_option_type::collate
        </li>
<li>
          POSIX collation sequences such as <code class="literal">
[.a.]
          </code> and <code class="literal">
[=a=]
          </code>
</li>
<li>
          Semantic actions
        </li>
<li>
          Fine-grained control over the dynamic regex syntax
        </li>
<li>
          Improved localization support, possibly as a custom facet for <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>
</li>
</ul></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.appendices.appendix_2__differences_from_boost_regex"></a>Appendix 2: Differences from Boost.Regex</h3></div></div></div>
<p>
        Since many of xpressive's users are likely to be familiar with the <a href="../../../libs/regex" target="_top">Boost.Regex</a> library, I would be remiss if
        I failed to point out some important differences between xpressive and <a href="../../../libs/regex" target="_top">Boost.Regex</a>. In particular:<br>
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          is a template on the iterator type, not the character type.
        </li>
<li>
<code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          cannot be constructed directly from a string; rather, you must use <code class="computeroutput"><span class="identifier">basic_regex</span><span class="special">::</span><span class="identifier">compile</span><span class="special">()</span></code>
          or <code class="computeroutput"><span class="identifier">regex_compiler</span><span class="special">&lt;&gt;</span></code>
          to build a regex object from a string.
        </li>
<li>
<code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          does not have an <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code> member function; rather, the <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>
          member function is in the <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">regex_compiler</span><span class="special">&lt;&gt;</span></code> factory.
        </li>
<li>
<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          has a subset of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;</span></code>'s
          members. <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          does not. The members lacking are: <code class="computeroutput"><span class="identifier">assign</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">operator</span><span class="special">[]()</span></code>, <code class="computeroutput"><span class="identifier">max_size</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">compare</span><span class="special">()</span></code>, and <code class="computeroutput"><span class="keyword">operator</span><span class="special">=(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;)</span></code>.
        </li>
<li>
          Other member functions that exist in <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code> but do not exist in <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          are: <code class="computeroutput"><span class="identifier">set_expression</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">get_allocator</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">imbue</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">getloc</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">getflags</span><span class="special">()</span></code>,
          and <code class="computeroutput"><span class="identifier">str</span><span class="special">()</span></code>.
        </li>
<li>
<code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          does not have a RegexTraits template parameter. Customization of regex
          syntax and localization behavior will be controlled by <code class="computeroutput"><span class="identifier">regex_compiler</span><span class="special">&lt;&gt;</span></code> and a custom regex facet for <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">locale</span></code>.
        </li>
<li>
<code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">basic_regex</span><span class="special">&lt;&gt;</span></code>
          and <code class="computeroutput"><span class="identifier">xpressive</span><span class="special">::</span><span class="identifier">match_results</span><span class="special">&lt;&gt;</span></code>
          do not have an Allocator template parameter. This is by design.
        </li>
<li>
<code class="computeroutput"><span class="identifier">match_not_dot_null</span></code> and
          <code class="computeroutput"><span class="identifier">match_not_dot_newline</span></code> have
          moved from the <code class="computeroutput"><span class="identifier">match_flag_type</span></code>
          enum to the <code class="computeroutput"><span class="identifier">syntax_option_type</span></code>
          enum, and they have changed names to <code class="computeroutput"><span class="identifier">not_dot_null</span></code>
          and <code class="computeroutput"><span class="identifier">not_dot_newline</span></code>.
        </li>
<li>
          The following <code class="computeroutput"><span class="identifier">syntax_option_type</span></code>
          enumeration values are not supported: <code class="computeroutput"><span class="identifier">escape_in_lists</span></code>,
          <code class="computeroutput"><span class="identifier">char_classes</span></code>, <code class="computeroutput"><span class="identifier">intervals</span></code>, <code class="computeroutput"><span class="identifier">limited_ops</span></code>,
          <code class="computeroutput"><span class="identifier">newline_alt</span></code>, <code class="computeroutput"><span class="identifier">bk_plus_qm</span></code>, <code class="computeroutput"><span class="identifier">bk_braces</span></code>,
          <code class="computeroutput"><span class="identifier">bk_parens</span></code>, <code class="computeroutput"><span class="identifier">bk_refs</span></code>, <code class="computeroutput"><span class="identifier">bk_vbar</span></code>,
          <code class="computeroutput"><span class="identifier">use_except</span></code>, <code class="computeroutput"><span class="identifier">failbit</span></code>, <code class="computeroutput"><span class="identifier">literal</span></code>,
          <code class="computeroutput"><span class="identifier">perlex</span></code>, <code class="computeroutput"><span class="identifier">basic</span></code>,
          <code class="computeroutput"><span class="identifier">extended</span></code>, <code class="computeroutput"><span class="identifier">emacs</span></code>, <code class="computeroutput"><span class="identifier">awk</span></code>,
          <code class="computeroutput"><span class="identifier">grep</span></code> ,<code class="computeroutput"><span class="identifier">egrep</span></code>,
          <code class="computeroutput"><span class="identifier">sed</span></code>, <code class="computeroutput"><span class="identifier">JavaScript</span></code>,
          <code class="computeroutput"><span class="identifier">JScript</span></code>.
        </li>
<li>
          The following <code class="computeroutput"><span class="identifier">match_flag_type</span></code>
          enumeration values are not supported: <code class="computeroutput"><span class="identifier">match_not_bob</span></code>,
          <code class="computeroutput"><span class="identifier">match_not_eob</span></code>, <code class="computeroutput"><span class="identifier">match_perl</span></code>, <code class="computeroutput"><span class="identifier">match_posix</span></code>,
          and <code class="computeroutput"><span class="identifier">match_extra</span></code>.
        </li>
</ul></div>
<p>
        Also, in the current implementation, the regex algorithms in xpressive will
        not detect pathological behavior and abort by throwing an exception. It is
        up to you to write efficient patterns that do not behave pathologically.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_xpressive.appendices.perf"></a> Appendix 3: Performance Comparison</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="appendices.html#boost_xpressive.appendices.perf.perf_gcc"> xpressive vs. Boost.Regex with GCC (Cygwin)</a></span></dt>
<dt><span class="section"><a href="appendices.html#boost_xpressive.appendices.perf.perf_msvc"> xpressive vs. Boost.Regex with Visual C++</a></span></dt>
</dl></div>
<p>
        The performance of xpressive is competitive with <a href="../../../libs/regex" target="_top">Boost.Regex</a>.
        I have run performance benchmarks comparing static xpressive, dynamic xpressive
        and <a href="../../../libs/regex" target="_top">Boost.Regex</a> on two platforms: gcc
        (Cygwin) and Visual C++. The tests include short matches and long searches.
        For both platforms, xpressive comes off well on short matches and roughly
        on par with <a href="../../../libs/regex" target="_top">Boost.Regex</a> on long searches.
      </p>
<p>
        &lt;disclaimer&gt; As with all benchmarks, the true test is how xpressive
        performs with <span class="emphasis"><em>your</em></span> patterns, <span class="emphasis"><em>your</em></span>
        input, and <span class="emphasis"><em>your</em></span> platform, so if performance matters
        in your application, it's best to run your own tests. &lt;/disclaimer&gt;
      </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_xpressive.appendices.perf.perf_gcc"></a> xpressive vs. Boost.Regex with GCC (Cygwin)</h4></div></div></div>
<p>
          Below are the results of a performance comparison between:
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            static xpressive
          </li>
<li>
            dynamic xpressive
          </li>
<li><a href="../../../libs/regex" target="_top">Boost.Regex</a></li>
</ul></div>
<div class="variablelist">
<p class="title"><b>Test Specifications</b></p>
<dl>
<dt><span class="term">Hardware:</span></dt>
<dd>
            hyper-threaded 3GHz Xeon with 1Gb RAM
          </dd>
<dt><span class="term">Operating System:</span></dt>
<dd>
            Windows XP Pro + Cygwin
          </dd>
<dt><span class="term">Compiler:</span></dt>
<dd>
            GNU C++ version 3.4.4 (Cygwin special)
          </dd>
<dt><span class="term">C++ Standard Library:</span></dt>
<dd>
            GNU libstdc++ version 3.4.4
          </dd>
<dt><span class="term"><a href="../../../libs/regex" target="_top">Boost.Regex</a>
          Version:</span></dt>
<dd>
            1.33+, BOOST_REGEX_USE_CPP_LOCALE, BOOST_REGEX_RECURSIVE
          </dd>
<dt><span class="term">xpressive Version:</span></dt>
<dd>
            0.9.6a
          </dd>
</dl>
</div>
<a name="boost_xpressive.appendices.perf.perf_gcc.comparison_1__short_matches"></a><h2>
<a name="id2053165"></a>
          Comparison 1: Short Matches
        </h2>
<p>
          The following tests evaluate the time taken to match the expression to
          the input string. For each result, the top number has been normalized relative
          to the fastest time, so 1.0 is as good as it gets. The bottom number (in
          parentheses) is the actual time in seconds. The best time has been marked
          in green.
        </p>
<div class="informaltable">
<h4>
<a name="id2053187"></a><span class="table-title">Short Matches</span>
</h4>
<table class="table">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>static xpressive</th>
<th>dynamic xpressive</th>
<th>Boost</th>
<th>Text</th>
<th>Expression</th>
</tr></thead>
<tbody>
<tr>
<td><span class="highlight">1<p></p>(8.79e&#8209;07s)</span></td>
<td><span class="highlight">1.08<p></p>(9.54e&#8209;07s)</span></td>
<td>2.51<p></p>(2.2e&#8209;06s)</td>
<td>100- this is a line of ftp response which contains a message string</td>
<td><code class="literal">^([0-9]+)(\-| |$)(.*)$</code></td>
</tr>
<tr>
<td><span class="highlight">1.06<p></p>(1.07e&#8209;06s)</span></td>
<td><span class="highlight">1<p></p>(1.01e&#8209;06s)</span></td>
<td>4.01<p></p>(4.06e&#8209;06s)</td>
<td>1234-5678-1234-456</td>
<td><code class="literal">([[:digit:]]{4}[- ]){3}[[:digit:]]{3,4}</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(1.4e&#8209;06s)</span></td>
<td>1.13<p></p>(1.58e&#8209;06s)</td>
<td>2.89<p></p>(4.05e&#8209;06s)</td>
<td>john_maddock@compuserve.com</td>
<td><code class="literal">^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(1.28e&#8209;06s)</span></td>
<td>1.16<p></p>(1.49e&#8209;06s)</td>
<td>3.07<p></p>(3.94e&#8209;06s)</td>
<td>foo12@foo.edu</td>
<td><code class="literal">^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(1.22e&#8209;06s)</span></td>
<td>1.2<p></p>(1.46e&#8209;06s)</td>
<td>3.22<p></p>(3.93e&#8209;06s)</td>
<td>bob.smith@foo.tv</td>
<td><code class="literal">^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$</code></td>
</tr>
<tr>
<td><span class="highlight">1.04<p></p>(8.64e&#8209;07s)</span></td>
<td><span class="highlight">1<p></p>(8.34e&#8209;07s)</span></td>
<td>2.5<p></p>(2.09e&#8209;06s)</td>
<td>EH10 2QQ</td>
<td><code class="literal">^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$</code></td>
</tr>
<tr>
<td>1.11<p></p>(9.09e&#8209;07s)</td>
<td><span class="highlight">1<p></p>(8.19e&#8209;07s)</span></td>
<td>2.47<p></p>(2.03e&#8209;06s)</td>
<td>G1 1AA</td>
<td><code class="literal">^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$</code></td>
</tr>
<tr>
<td>1.12<p></p>(9.38e&#8209;07s)</td>
<td><span class="highlight">1<p></p>(8.34e&#8209;07s)</span></td>
<td>2.5<p></p>(2.08e&#8209;06s)</td>
<td>SW1 1ZZ</td>
<td><code class="literal">^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(7.9e&#8209;07s)</span></td>
<td><span class="highlight">1.06<p></p>(8.34e&#8209;07s)</span></td>
<td>2.49<p></p>(1.96e&#8209;06s)</td>
<td>4/1/2001</td>
<td><code class="literal">^[[:digit:]]{1,2}/[[:digit:]]{1,2}/[[:digit:]]{4}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(8.19e&#8209;07s)</span></td>
<td><span class="highlight">1.04<p></p>(8.49e&#8209;07s)</span></td>
<td>2.4<p></p>(1.97e&#8209;06s)</td>
<td>12/12/2001</td>
<td><code class="literal">^[[:digit:]]{1,2}/[[:digit:]]{1,2}/[[:digit:]]{4}$</code></td>
</tr>
<tr>
<td><span class="highlight">1.09<p></p>(8.95e&#8209;07s)</span></td>
<td><span class="highlight">1<p></p>(8.19e&#8209;07s)</span></td>
<td>2.4<p></p>(1.96e&#8209;06s)</td>
<td>123</td>
<td><code class="literal">^[-+]?[[:digit:]]*\.?[[:digit:]]*$</code></td>
</tr>
<tr>
<td>1.11<p></p>(8.79e&#8209;07s)</td>
<td><span class="highlight">1<p></p>(7.9e&#8209;07s)</span></td>
<td>2.57<p></p>(2.03e&#8209;06s)</td>
<td>+3.14159</td>
<td><code class="literal">^[-+]?[[:digit:]]*\.?[[:digit:]]*$</code></td>
</tr>
<tr>
<td><span class="highlight">1.09<p></p>(8.94e&#8209;07s)</span></td>
<td><span class="highlight">1<p></p>(8.19e&#8209;07s)</span></td>
<td>2.47<p></p>(2.03e&#8209;06s)</td>
<td>-3.14159</td>
<td><code class="literal">^[-+]?[[:digit:]]*\.?[[:digit:]]*$</code></td>
</tr>
</tbody>
</table>
</div>
<a name="boost_xpressive.appendices.perf.perf_gcc.comparison_2__long_searches"></a><h2>
<a name="id2053664"></a>
          Comparison 2: Long Searches
        </h2>
<p>
          The next test measures the time to find <span class="emphasis"><em>all</em></span> matches
          in a long English text. The text is the <a href="http://www.gutenberg.org/dirs/3/2/0/3200/3200.zip" target="_top">complete
          works of Mark Twain</a>, from <a href="http://promo.net/pg/" target="_top">Project
          Gutenberg</a>. The text is 19Mb long. As above, the top number is the
          normalized time and the bottom number is the actual time. The best time
          is in green.
        </p>
<div class="informaltable">
<h4>
<a name="id2053702"></a><span class="table-title">Long Searches</span>
</h4>
<table class="table">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>static xpressive</th>
<th>dynamic xpressive</th>
<th>Boost</th>
<th>Expression</th>
</tr></thead>
<tbody>
<tr>
<td><span class="highlight">1<p></p>(0.0263s)</span></td>
<td><span class="highlight">1<p></p>(0.0263s)</span></td>
<td>1.78<p></p>(0.0469s)</td>
<td><code class="literal">Twain</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(0.0234s)</span></td>
<td><span class="highlight">1<p></p>(0.0234s)</span></td>
<td>1.79<p></p>(0.042s)</td>
<td><code class="literal">Huck[[:alpha:]]+</code></td>
</tr>
<tr>
<td>1.84<p></p>(1.26s)</td>
<td>2.21<p></p>(1.51s)</td>
<td><span class="highlight">1<p></p>(0.687s)</span></td>
<td><code class="literal">[[:alpha:]]+ing</code></td>
</tr>
<tr>
<td><span class="highlight">1.09<p></p>(0.192s)</span></td>
<td>2<p></p>(0.351s)</td>
<td><span class="highlight">1<p></p>(0.176s)</span></td>
<td><code class="literal">^[^
]*?Twain</code></td>
</tr>
<tr>
<td>1.41<p></p>(0.08s)</td>
<td>1.21<p></p>(0.0684s)</td>
<td><span class="highlight">1<p></p>(0.0566s)</span></td>
<td><code class="literal">Tom|Sawyer|Huckleberry|Finn</code></td>
</tr>
<tr>
<td>1.56<p></p>(0.195s)</td>
<td>1.12<p></p>(0.141s)</td>
<td><span class="highlight">1<p></p>(0.125s)</span></td>
<td><code class="literal">(Tom|Sawyer|Huckleberry|Finn).{0,30}river|river.{0,30}(Tom|Sawyer|Huckleberry|Finn)</code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_xpressive.appendices.perf.perf_msvc"></a> xpressive vs. Boost.Regex with Visual C++</h4></div></div></div>
<p>
            Below are the results of a performance comparison between:
          </p>
<div class="itemizedlist"><ul type="disc">
<li>
              static xpressive
            </li>
<li>
              dynamic xpressive
            </li>
<li><a href="../../../libs/regex" target="_top">Boost.Regex</a></li>
</ul></div>
<div class="variablelist">
<p class="title"><b>Test Specifications</b></p>
<dl>
<dt><span class="term">Hardware:</span></dt>
<dd>
              hyper-threaded 3GHz Xeon with 1Gb RAM
            </dd>
<dt><span class="term">Operating System:</span></dt>
<dd>
              Windows XP Pro
            </dd>
<dt><span class="term">Compiler:</span></dt>
<dd>
              Visual C++ .NET 2003 (7.1)
            </dd>
<dt><span class="term">C++ Standard Library:</span></dt>
<dd>
              Dinkumware, version 313
            </dd>
<dt><span class="term"><a href="../../../libs/regex" target="_top">Boost.Regex</a>
            Version:</span></dt>
<dd>
              1.33+, BOOST_REGEX_USE_CPP_LOCALE, BOOST_REGEX_RECURSIVE
            </dd>
<dt><span class="term">xpressive Version:</span></dt>
<dd>
              0.9.6a
            </dd>
</dl>
</div>
<a name="boost_xpressive.appendices.perf.perf_msvc.comparison_1__short_matches"></a><h2>
<a name="id2054029"></a>
            Comparison 1: Short Matches
          </h2>
<p>
            The following tests evaluate the time taken to match the expression to
            the input string. For each result, the top number has been normalized
            relative to the fastest time, so 1.0 is as good as it gets. The bottom
            number (in parentheses) is the actual time in seconds. The best time
            has been marked in green.
          </p>
<div class="informaltable">
<h4>
<a name="id2054051"></a><span class="table-title">Short Matches</span>
</h4>
<table class="table">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>static xpressive</th>
<th>dynamic xpressive</th>
<th>Boost</th>
<th>Text</th>
<th>Expression</th>
</tr></thead>
<tbody>
<tr>
<td><span class="highlight">1<p></p>(3.2e&#8209;007s)</span></td>
<td>1.37<p></p>(4.4e&#8209;007s)</td>
<td>2.38<p></p>(7.6e&#8209;007s)</td>
<td>100- this is a line of ftp response which contains a message string</td>
<td><code class="literal">^([0-9]+)(\-| |$)(.*)$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(6.4e&#8209;007s)</span></td>
<td>1.12<p></p>(7.15e&#8209;007s)</td>
<td>1.72<p></p>(1.1e&#8209;006s)</td>
<td>1234-5678-1234-456</td>
<td><code class="literal">([[:digit:]]{4}[- ]){3}[[:digit:]]{3,4}</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(9.82e&#8209;007s)</span></td>
<td>1.3<p></p>(1.28e&#8209;006s)</td>
<td>1.61<p></p>(1.58e&#8209;006s)</td>
<td>john_maddock@compuserve.com</td>
<td><code class="literal">^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(8.94e&#8209;007s)</span></td>
<td>1.3<p></p>(1.16e&#8209;006s)</td>
<td>1.7<p></p>(1.52e&#8209;006s)</td>
<td>foo12@foo.edu</td>
<td><code class="literal">^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(9.09e&#8209;007s)</span></td>
<td>1.28<p></p>(1.16e&#8209;006s)</td>
<td>1.67<p></p>(1.52e&#8209;006s)</td>
<td>bob.smith@foo.tv</td>
<td><code class="literal">^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(3.06e&#8209;007s)</span></td>
<td><span class="highlight">1.07<p></p>(3.28e&#8209;007s)</span></td>
<td>1.95<p></p>(5.96e&#8209;007s)</td>
<td>EH10 2QQ</td>
<td><code class="literal">^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(3.13e&#8209;007s)</span></td>
<td><span class="highlight">1.09<p></p>(3.42e&#8209;007s)</span></td>
<td>1.86<p></p>(5.81e&#8209;007s)</td>
<td>G1 1AA</td>
<td><code class="literal">^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(3.2e&#8209;007s)</span></td>
<td><span class="highlight">1.09<p></p>(3.5e&#8209;007s)</span></td>
<td>1.86<p></p>(5.96e&#8209;007s)</td>
<td>SW1 1ZZ</td>
<td><code class="literal">^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(2.68e&#8209;007s)</span></td>
<td>1.22<p></p>(3.28e&#8209;007s)</td>
<td>2<p></p>(5.36e&#8209;007s)</td>
<td>4/1/2001</td>
<td><code class="literal">^[[:digit:]]{1,2}/[[:digit:]]{1,2}/[[:digit:]]{4}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(2.76e&#8209;007s)</span></td>
<td>1.16<p></p>(3.2e&#8209;007s)</td>
<td>1.94<p></p>(5.36e&#8209;007s)</td>
<td>12/12/2001</td>
<td><code class="literal">^[[:digit:]]{1,2}/[[:digit:]]{1,2}/[[:digit:]]{4}$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(2.98e&#8209;007s)</span></td>
<td><span class="highlight">1.03<p></p>(3.06e&#8209;007s)</span></td>
<td>1.85<p></p>(5.51e&#8209;007s)</td>
<td>123</td>
<td><code class="literal">^[-+]?[[:digit:]]*\.?[[:digit:]]*$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(3.2e&#8209;007s)</span></td>
<td>1.12<p></p>(3.58e&#8209;007s)</td>
<td>1.81<p></p>(5.81e&#8209;007s)</td>
<td>+3.14159</td>
<td><code class="literal">^[-+]?[[:digit:]]*\.?[[:digit:]]*$</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(3.28e&#8209;007s)</span></td>
<td>1.11<p></p>(3.65e&#8209;007s)</td>
<td>1.77<p></p>(5.81e&#8209;007s)</td>
<td>-3.14159</td>
<td><code class="literal">^[-+]?[[:digit:]]*\.?[[:digit:]]*$</code></td>
</tr>
</tbody>
</table>
</div>
<a name="boost_xpressive.appendices.perf.perf_msvc.comparison_2__long_searches"></a><h2>
<a name="id2054518"></a>
            Comparison 2: Long Searches
          </h2>
<p>
            The next test measures the time to find <span class="emphasis"><em>all</em></span> matches
            in a long English text. The text is the <a href="http://www.gutenberg.org/dirs/3/2/0/3200/3200.zip" target="_top">complete
            works of Mark Twain</a>, from <a href="http://promo.net/pg/" target="_top">Project
            Gutenberg</a>. The text is 19Mb long. As above, the top number is
            the normalized time and the bottom number is the actual time. The best
            time is in green.
          </p>
<div class="informaltable">
<h4>
<a name="id2054557"></a><span class="table-title">Long Searches</span>
</h4>
<table class="table">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>static xpressive</th>
<th>dynamic xpressive</th>
<th>Boost</th>
<th>Expression</th>
</tr></thead>
<tbody>
<tr>
<td><span class="highlight">1<p></p>(0.019s)</span></td>
<td><span class="highlight">1<p></p>(0.019s)</span></td>
<td>2.98<p></p>(0.0566s)</td>
<td><code class="literal">Twain</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(0.0176s)</span></td>
<td><span class="highlight">1<p></p>(0.0176s)</span></td>
<td>3.17<p></p>(0.0556s)</td>
<td><code class="literal">Huck[[:alpha:]]+</code></td>
</tr>
<tr>
<td>3.62<p></p>(1.78s)</td>
<td>3.97<p></p>(1.95s)</td>
<td><span class="highlight">1<p></p>(0.492s)</span></td>
<td><code class="literal">[[:alpha:]]+ing</code></td>
</tr>
<tr>
<td>2.32<p></p>(0.344s)</td>
<td>3.06<p></p>(0.453s)</td>
<td><span class="highlight">1<p></p>(0.148s)</span></td>
<td><code class="literal">^[^
]*?Twain</code></td>
</tr>
<tr>
<td><span class="highlight">1<p></p>(0.0576s)</span></td>
<td><span class="highlight">1.05<p></p>(0.0606s)</span></td>
<td>1.15<p></p>(0.0664s)</td>
<td><code class="literal">Tom|Sawyer|Huckleberry|Finn</code></td>
</tr>
<tr>
<td>1.24<p></p>(0.164s)</td>
<td>1.44<p></p>(0.191s)</td>
<td><span class="highlight">1<p></p>(0.133s)</span></td>
<td><code class="literal">(Tom|Sawyer|Huckleberry|Finn).{0,30}river|river.{0,30}(Tom|Sawyer|Huckleberry|Finn)</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<table width="100%"><tr>
<td align="left"></td>
<td align="right"><small>Copyright © 2003, 2004 Eric Niebler</small></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../boost_xpressive/acknowledgments.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../xpressive.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="../tools.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
